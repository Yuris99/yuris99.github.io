{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Codeforces Round #739 (Div. 3) 리뷰","text":"알고리즘 공부를 열심히 하겠다고 마음먹은뒤 결국 Div. 2 하나를 놓치고 지나갔다.결국 바로 다음에 있는 Div. 3부터 치르게 되었는데, 오랜만이라 그런가 생각보다 쉽지 않았다.앞으로 알고리즘 공부한것들의 리뷰를 해볼생각이다. 실력이 조금이라도 늘겠지… Result # A B C D E F1 F2 Attr 1 3 1 0 - - - Attr* - - - 1 - - - Time 20 55 15 Over - - - Solve O O O Late - - - Adjustment Rating Ranking Tear 1023 (+49) 10341 (+3079) Newbie","link":"/2021/08/19/codeforces-739/"},{"title":"Codeforces Round #739 (Div. 3) Problem. C","text":"https://codeforces.com/contest/1560/problem/CCodeforces Round #739 (Div. 3) C. Infinity Table TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 implementation math Attr SubNo SolveTime Time Memory Accept? 1 126343911 +14min (70m) 30 ms 3600KB Accepted 문제 요약2차원배열 가장 왼쪽 위부터 시작하는 table이 있다. 이table은 다음과같은 패턴으로 순서대로 생성이 된다.위와같은 패턴으로 table이 무한정 생성될 때 k가 존재하는 행과 열을 구하여라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= k &lt;= 109) Output각 Testcase 마다2개의 정수 (r, c &gt;= 1) space로 구분 : k가 위치하고있는 열과 행 문제 풀이또 800점 문제이다. 또한 패턴만 구하면 간단하게 해결할 수 있었다. 0번째 열을 확인해보면 각각 n번째 행의 원소들이 n의 제곱인것을 확인할 수 있다.다르게 말하면 0번째 행의 0보다 큰 n번째 열의 원소는 n-1의 제곱 + 1이라는 사실도 성립된다.또한 변화하는 행과 열의 종류가 변경되는 시점은 n-1의 제곱 + (n-1)이기 때문에 k의 위치는 쉽게 구할 수 있었다. 최종 해설먼저 정수형 sq를 선언하여 k의 제곱근(소수점부분은 제외)을 구하였다. 만약 소수점을 제외한 sq의 제곱이 k와 같다면, k의 위치는 0열 sq행으로 고정되기 때문에 예외를 두어 처리를 해 주었다. 다음으로 알아야 하는것은 k가 위치하고 있는 곳이 열이 변경되는 구간인지, 행이 변경되는 구간인지 알 필요가 있다.먼저 행과 열이 바뀌는 구간은 sq의 제곱 + sq로 구할 수 있다. (행과 열이 만나는 시점) 따라서 해당 값보다 크게 되면, 가로로 배치되는 시점이므로 행의 위치는 sq+1로 고정이며 열의 위치는 sq+1의 제곱에서 k값을 뺀 값이 k가 위치하는 열의 번호가 된다. 또는 행과 열이 만나는 시점보다 k의 값이 작게 되면, 세로로 배치되는 시점이므로 열의 위치는 sq+1로 고정이며 행의 위치는 k에서 sq의 제곱을 뺀 값이 된다. 최종 코드12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;math.h&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int k; cin &gt;&gt; k; int sq = (int)sqrt(k); if(sq*sq == k) { cout &lt;&lt; sq &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt; endl; continue; } if(k &gt; sq*sq+sq) cout &lt;&lt; sq+1 &lt;&lt; &quot; &quot; &lt;&lt; sq-(k-(sq*sq)-sq)+2 &lt;&lt; endl; else cout &lt;&lt; k-(sq*sq) &lt;&lt; &quot; &quot; &lt;&lt; sq+1 &lt;&lt; endl; } return 0;} 느낀점어렵지 않았다. 간단한 공식을 알아내면 쉽게 풀 수 있는 문제였다.앞에서 뻘짓한게 아까웠다..","link":"/2021/08/25/codeforces-739-C/"},{"title":"Codeforces Round #739 (Div. 3) Problem. A","text":"https://codeforces.com/contest/1560/problem/ACodeforces Round #739 (Div. 3) A. Dislike of Threes TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 implementation Attr SubNo SolveTime Time Memory Accept? 1 126297598 20min 31 ms 3660KB Accepted 문제 요약Polycarp은 3을 싫어한다. 3으로 끝나는 문자와 3으로 나누어 떨어지는 문자를 제외하고 숫자를 세어서 n번째 숫자를 구해라 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= k &lt;= 1000) Output각 Testcase 마다1개의 정수 x : Polycarp이 싫어하지 않는 k-th 숫자 문제 풀이정말 간단하게 풀 수 있다. 단순한 1차원 반복문을 사용하여 num이 3으로 나누어떨어지거나 3으로 끝나면(10으로 나누었을때 나머지가 3이면) 한번 더 더해서 카운트를 건너뛰어주었다. 최종 코드123456789101112131415161718192021#include &lt;iostream&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int k; cin &gt;&gt; k; int num = 0; for(int i = 1; i &lt;= k; i++) { num++; while(num % 3 == 0 || num % 10 == 3) num++; } cout &lt;&lt; num &lt;&lt; endl; } return 0;} 느낀점800점대 문제면서 Div. 3 A번 문제라 정말 쉬웠다. 간단한 루프문으로 해결될줄은 몰랐지만 생각보다 빠르게 끝냈다.","link":"/2021/08/21/codeforces-739-A/"},{"title":"Codeforces Round #739 (Div. 3) Problem. B","text":"https://codeforces.com/contest/1560/problem/BCodeforces Round #739 (Div. 3) B. Who’s Opposite? TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 math Attr SubNo SolveTime Time Memory Accept? 1 126327661 +40min 1000 ms 3700KB Time limit 2 126332184 +8min (48m) 77 ms 3600KB Wrong answer 3 126336434 +8min (56m) 93 ms 3700KB Accepted 문제 요약원형의 식탁에서 회의를 하는데 인원은 모르고(짝수이다) 모든 사람은 서로 마주보는 상대가 있다.각자의 번호는 1부터 시작해서 시계방향으로 숫자를 매긴다.a 와 b가 마주보고 있을 때, c와 마주보고 있는 사람의 번호를 구하여라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 104)각 Testcase 마다t-th line : space로 구분된 3개의 정수 (1 &lt;= a, b, c &lt;= 108) Output각 Testcase 마다1개의 정수 d : c와 마주보고있는 숫자답이 여러개일시 아무거나 출력, 답이 없으면 -1출력 문제 풀이이문제 또한 어려운 문제는 아니였다. 규칙만 잘 찾으면 되는 문제였지만, 예상외로 해맸었다. Attr 1 (Time Limit exceeded on test 2)첫시도부터 굉장히 복잡하게 생각을 했는데 일단 무조건 규칙이 있을것이라고 예상을 하였다. 그래서 열심히 규칙을 찾아본 결과..서로 마주보는 a와 b를 기준으로 a-n은 b-n을 마주보고 있다는 사실을 알게 되었다.또한 계속 빼가다가 어느 한 수가 0에 도달하게 되면, 큰수 + (큰수 - n - 작은수)가 원탁에 앉아있는 총 인원 수가 나왔다. 복잡하다또는 큰수-n과 작은수의 값이 같아지면, 큰수 + (작은수 - n) 의 값이 총 인원수가 되었다. 결국 for문으로 돌려서 위 두 케이스중 하나의 케이스가 나오게 되면 Loop를 빠져나가고 남은 값들을 계산하여 값을 도출해 냈다. 물론 결과는 시간 초과최대 시간복잡도가 104X108 = 1012(약 1조…)가 나와버린다… 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); int i, meet = small - 1; int result = -1; for (i = big-1; i &gt; small &amp;&amp; meet &gt; 0; i--, meet--) { if (result == -1) { if(i == c) result = meet; else if(meet == c) result = i; } } //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;, m = &quot; &lt;&lt; meet &lt;&lt; endl; if(result == -1 &amp;&amp; i &gt; small &amp;&amp; meet == 0) { if(c &gt; small &amp;&amp; c &lt;= i) result = big + (c-small); else if(c &gt; big &amp;&amp; c &lt;= (big + (i-small))) result = small + (c-big); } cout &lt;&lt; result &lt;&lt; endl; } return 0;} Attr 2 (Wrong answer on test 2)시간초과로 한대 맞고난 뒤 for문으로 해결할 수 없는 문제라는 사실을 문제를 본지 40분만에 알아차렸다. 결국 다른 규칙을 찾다가 한가지 핵심적인 규칙을 깨닳을 수 있었다. 서로 마주보고있는 두 수의 간격은 무조건 전체 인원수의 절반이 된다.이 규칙을 찾은 후 이 규칙을 가지고 코드를 짰다. 기본적으로 두 수의 간격을 구하고, 그 간격을 기준으로 c값이 작으면 전체 인원수의 절반을 더해주고, c값이 크면 전체 인원수의 절반을 빼주는 형식으로 정답을 구했다. 또한 몇가지의 예외사항을 넣어두었다. 앞에서 했던 for문 뻘짓을 왜했는지 이해가 되지 않았지만 8분만에 코드를 짜고 제출을 하였다.그러나 결과는 오답공식에는 문제가 없었다. 다른 예외사항이 있는듯했다. 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c, result = -1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); int dis = big - small; if(c &gt; dis) result = c-dis; else if (c &lt;= dis) result = c + dis; if(result &gt; dis*2 || big &gt; dis*2) result = -1; cout &lt;&lt; result &lt;&lt; endl; } return 0;} Attr 3 (Accepted!)결국 또하나의 예외를 찾아내고 나서야 문제를 해결할 수 있었다. “c가 전체 인원수보다 크면: a와 b가 마주보고 있는 원탁에는 c는 존재할 수 없다.”결론적으로 이 예외조건을 추가하니 정상적으로 코드가 Accept 되었다. 최종 해설서로 마주보고있는 두 수의 간격은 무조건 전체 인원수의 절반이 된다. a와 b를 사용하여 전체 인원수의 절반을 구하고, 그 수를 기준으로 하여 c에 따라서 결과값을 구해주면 된다.규칙만 잘찾으면 어렵지않게 풀 수 있는 문제였다. 괜히 반복문으로 접근해서 시간만 날렸다 ?c가 전체 인원수의 절반보다 작거나 같으면: 정답 : c + 전체 인원수의 절반; ?아니면 c가 전체 인원수의 절반보다 크면: 정답 : c - 전체 인원수의 절반; 만약: 정답이 전체 인원수보다 크면: 정답 : -1; 제대로된 원탁이 아니다. 또는: c가 전체 인원수보다 크면: 정답 : -1; a와 b가 마주보고 있는 원탁에는 c는 존재할 수 없다. 또는: a와 b중에 큰 수가 전체 인원수보다 크면: 정답 : -1; a와 b중에 큰 수는 제대로된 원탁에 존재할 수 없다. 최종 코드12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c, result = -1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); //총 인원수의 절반 int dis = big - small; if(c &gt; dis) result = c-dis; else if (c &lt;= dis) result = c + dis; //답이 나오지 않는 경우 if(result &gt; dis*2 || big &gt; dis*2 || c &gt; dis*2) result = -1; cout &lt;&lt; result &lt;&lt; endl; } return 0;} 느낀점원형탁자 -&gt; 숫자 -&gt; 순서대로 -&gt; 반복문!! 일것이라고 안일하개 생각한게 문제가 되었다.결국 초반에 반복문으로 계속 고민을 하다가 시간만 날려버리게 되었다.문제를 해결하는 방법에 편견을 가지지 말고 다양한 방법을 생각해 봐야할 것 같다.","link":"/2021/08/23/codeforces-739-B/"},{"title":"Codeforces Round #739 (Div. 3) Problem. D (After contest)","text":"https://codeforces.com/contest/1560/problem/DCodeforces Round #739 (Div. 3) D. Make a Power of Two TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 1300 greedy math strings Attr SubNo SolveTime Time Memory Accept? -1 126372797 TIME OVER 233 ms 3700KB Accepted(Late) 문제 요약2의 제곱으로 만들어라. 정수 n이 주어지고, 다음과 같은 행동을 할 수 있다. 임의의 숫자 하나를 지울 수 있다 (만약 숫자가 하나밖에 남지 않았으면 “empty”가 된다) 오른쪽에 숫자 하나를 놓을 수 있다. 가장 왼쪽에 0이 있을 때, 0은 지워지지 않는다.예시) 301에서 3을 빼면, 1이 아닌 01이 된다 최소한의 행동만 하여 n을 2의 제곱으로 만들어라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 104)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= n &lt;= 109) Output각 Testcase 마다1개의 정수 m : 2의 제곱으로 만드는 최소 비용 문제 풀이처음엔 햇갈렸지만, 결국 string을 사용하여 노가다로 풀 수 있는 문제라는 사실을 깨닳았다. 하나의 문자를 구현하기 위해서는 구현할 문자와 비교해가면서 필요없는 숫자는 빼고, 필요한 숫자만 마지막에 더해주면 쉽게 구현을 할 수 있다.(비용은 언제나 최소비용이 든다) 또한 n의 최대 범위가 10의 9승이기 때문에, 아무리 비용이 많이 들어도 9 이상으로는 들지 않을 것이다.10의 9승 이하에서 모든 값을 지우고 1만 추가하면 최대 9의 비용이 나온다 처음엔 long long int의 최대 범위를 10의 19승까지 했지만, 잘못된 선택이였다. long long int의 범위를 잘못 알고 있었었다. 이부분에서 시간을 많이 잡아먹었다결국 long long int의 범위 문제였고, 범위를 10의 18승으로 줄여 문제를 해결했다. 최종 해설먼저 간단한 예외(n이 이미 2의 제곱일때)는 미리 검사하고 걸러냈다. 만약 그렇지 않으면, n을 string으로 바꿔서 시작한다. 그 뒤로 2의 제곱을 계속해서 비교해 가면서 최소비용을 계산을 한다.만약 비용이 1이 나오면, 1보다 작은 비용은 나오지 않기 때문에 검사를 종료하였다. 검사는 n의 digit들을 하나씩 돌아가면서 구현할 숫자와 비교를 한다.n과 다른 숫자가 있으면 해당 digit를 제거하고, n의 탐색이 먼저 끝나면 남은 digit들을 추가해주면 구현이 완료된다. n의 최대값은 109이므로 가장 큰 최소 비용은 9가 된다.10의 9승 이하에서 모든 값을 지우고 1만 추가하면 최대 9의 비용이 나온다그러므로 +-를 계산하여 구현해볼 최대의 2의 제곱수는 1018 까지 확인을 해 주었다. 최종 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;string&gt; using namespace std; bool CheckPow(int a) { while(a &gt; 1) { if(a % 2) return false; a/=2; } return true;} long long int Power(long long int a, long long int b) { long long int result = a; for(long long int i = 1; i &lt; b; i++) result = result * a; return result;} int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int n; cin &gt;&gt; n; if(CheckPow(n)) { cout &lt;&lt; 0 &lt;&lt; endl; continue; } string num = to_string(n); long long int now = 1; int result = 15; int weight = 9; //cout &lt;&lt; (long long int)powl(10, 20) &lt;&lt; endl; //cout &lt;&lt; Power(10, 18) &lt;&lt; endl; while (result &gt; 1 &amp;&amp; now &lt; Power(10, 18)) { string nstr = to_string(now); int i = 0, j = 0; int trash = 0; for(i = 0; i &lt; nstr.length(); i++) { for(j; j &lt; num.length(); j++) { if(nstr[i] == num[j]) break; trash++; } if(j==num.length()) { trash += nstr.length() - i; break; } else j++; } result = min(result, trash + (int)(num.length()-j)); now *= 2; } cout &lt;&lt; result &lt;&lt; endl; } return 0;} 느낀점처음 봤을 때 막막했지만, 오랜시간 고민해본 결과 해법을 알아내고 시간은 얼마 남지 않았었다.결국 오류를 잡지 못하고 대회가 종료되고 말았다. 결국 int의 범위 때문에 큰 오류가 났었는데, 다음부턴 최대값을 정하고 작업을 하는게 안전할 것 같다.","link":"/2021/08/25/codeforces-739-D/"},{"title":"Codeforces Round #740 (Div. 2) Problem. A","text":"https://codeforces.com/contest/1561/problem/ACodeforces Round #740 (Div. 2, based on VK Cup 2021 - Final (Engine)) A. Simply Strange Sort TimeLimit MemoryLimit Difficulty Tags 2 S 512 MB 800 brute force implementation sortings Attr SubNo SolveTime Time Memory Accept? 1 126892151 20min 31 ms 3600KB Wrong answer 2 126900288 +25min (45m) 46 ms 3700KB Accepted 문제 요약조금 이상한 정렬.. n개의 원소를 가지고있는 배열 a(n개의 원소를 가진 배열, n: 홀수)이 주어진다.배열 a를 오름차순으로 정렬한다. 알고리즘: f(i)를 수행한다.i는 (1 &lt;= i &lt;= n-1)사이로 수행되고, 각 다음과 같은 알고리즘을 사용한다 : 만약 **ai &gt; ai+1**이면, **ai 와 ai+1의 값을 변경한다. 알고리즘은 반복으로 구성되고, 숫자 1부터 시작한다. i번째 반복일 때, 다음과 같은 알고리즘을 수행한다 만약 i가 홀수이면: f(1), f(3),…,f(n-2);를 호출 만약 i가 짝수이면: f(2), f(4),…,f(n-1);를 호출 배열이 오름차순으로 정렬될 때까지 반복한다. 몇번의 반복을 해야 오름차순으로 정렬되는지 구하는 문제… 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다 1-st line : 1개의 정수 (1 &lt;= n &lt;= 1000, n: 홀수) 2-nd line : n개의 정수 a1, a2…,an (1 &lt;= ai &lt;= n) 모든 테스트케이스의 n의 합이 999를 넘지 않는다. Output각 Testcase 마다최초로 오름차순으로 정렬이 되는 최소 반복 횟수를 출력 이미 정렬이 되어있다면, 0을 출력 문제 풀이그냥 무시정으로 반복해도 해결할 수 있는 문제이다. 알고리즘도 다 알려주고 위에서 시키는대로 코드를 짜기만 하면 되는 문제 Attr 1 (Wrong answer on pretest 2)처음에는 checkSorted라는 변수를 하나 만들어서 반복문 안에서 변경되는 점이 있으면 checkSorted를 꺼주고, checkSorted가 꺼지지 않으면 정렬이 된것으로 보고 반복문을 탈출시켜주는 코드였다. 에러가 떴다. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int result = 0; int n, arr[1001]; cin &gt;&gt; n; arr[0] = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; arr[i]; } while(true) { result ++; int checkSorted = true; for(int i = (result%2==0?2:1); i &lt; n; i+=2) { if(arr[i] &gt; arr[i+1]) { //cout &lt;&lt; &quot;exchange &quot; &lt;&lt; arr[i] &lt;&lt; &quot; and &quot; &lt;&lt; arr[i+1] &lt;&lt; endl; int temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; checkSorted = false; } if(arr[i-1] &gt; arr[i]) checkSorted = false; } if(checkSorted) break; } cout &lt;&lt; result - 1 &lt;&lt; endl; } return 0;} Attr 2 (Accepted!)에러가 날만한 테스트 케이스를 하나씩 넣어봤는데 바로 발견할 수 있었다. 1251 2 3 5 4 위의 케이스를 넣었을때, 확인이 되지않고 0으로 출력이 되었다.바로 해결할 수 있는 문제였는데, 햇갈려서 알고리즘을 다시 짜는 수준까지 가버렸다. 시간이 더 걸리더라도 그냥 배열이 정렬되었는지 미리 확인을 하는 코드를 추가했는데, 시간제한이 넉넉하다보니 문제없이 잘 작동하였었다. 바로 해결하지 못한 이유는 위 케이스의 답이 2가아닌 1이라 생각하고 삽질하고 있었다… 최종 해설위의 해설이랑 똑같이 만들었다. n을 먼저받고, 문제에서 1부터 시작했기 때문에 햇갈리지 않기 위해서 배열의 0은 0으로 채워주고 1부터 입력값을 받아주었다. (1~`n`) 그다음 정렬이 될 때까지 무한반복을 해주는데, 먼저 배열이 정렬되었는지 확인을 해준다. 단순히 for문으로 반복하면서 비교를 해주었다. 정렬이 되지않았으면 result값을 1 더해주고 문제에 나온 알고리즘을 수행해준다. 이렇게 반복하면 어렵지 않게 답을 구할 수 있다. 최종 코드12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int result = 0; int n, arr[1001]; cin &gt;&gt; n; arr[0] = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; arr[i]; } while(true) { //check if array sorted int i = 1; for(i; i &lt; n; i++) if(arr[i] &gt; arr[i+1]) break; if(i == n) break; result ++; for(int i = (result%2==0?2:1); i &lt; n; i+=2) { if(arr[i] &gt; arr[i+1]) { //cout &lt;&lt; &quot;exchange &quot; &lt;&lt; arr[i] &lt;&lt; &quot; and &quot; &lt;&lt; arr[i+1] &lt;&lt; endl; int temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; } } } cout &lt;&lt; result &lt;&lt; endl; } return 0;} 느낀점알람은 미리미리 맞춰놓자.정신좀 차리자.","link":"/2021/08/25/codeforces-740-A/"},{"title":"Codeforces Round #740 (Div. 2) 리뷰","text":"서론Codeforces Round #740 (Div. 2, based on VK Cup 2021 - Final (Engine))VK Cup의 최종 문제를 기준으로 출제된 Contest이다. 사실 뭔지 잘 모르지만, 확실한건 내가 알람을 맞춰두지 않았다는 사실이다. 문제를 풀기 시작한 시점은 1시간이 남았을때였다. 2점밖에 올리지 못했는데 1887등이 올랐다…. 이것이 심해인가보다 Result # A B C D E F1 F2 Attr 2 - - - - - - Attr* - - - - - - - Time 45 - - - - - - Solve O - - - - - - Adjustment Rating Ranking Tear 1025 (+2) 8454 (+1887) Newbie","link":"/2021/08/25/codeforces-740/"},{"title":"[강의정리] 데이터통신과네트워크 OT","text":"수업 개요 TCP/IP 모델을 사용하여 인터넷이 동작하는 원리를 학습 수업 교재 Computer Networking: A Top-Down Approach, 7th Edition (Pearson) James Kurose and Keith Ross 교재에 포함되지 않는 내용은 강의교안을 통해 제공 중간 기말 일정 중간시험 (8주차) 2021년 10월 21일 목요일 오후 7시 (오프라인) 기말시험 (15주차) 2021년 12월 9일 목요일 오후 7시 (오프라인) 성적 처리 중간/기말 시험 60% 기말시험범위: 전범위 과제물 제출 30% 퀴즈 및 과제 포함 출석 및 수업태도 10%","link":"/2021/09/06/dataNetwork-W1-OT/"},{"title":"[강의정리] 데이터통신과네트워크 Overview(2)","text":"네트워크 계층 구조네트워크 계층 구조: 네트워크 계층네트워크 계층 프로토콜: ARP (Address Resolution Protocol) 데이터를 전달하려는 IP 주소와 통신에 필요한 물리적인 주소(MAC)를 알아내는 프로토콜 선택된 매체에 브로드캐스트를 통해 특정 IP 주소를 사용하는 호스트가 응답을 하도록 요구하는 방식을 사용 네트워크 계층 프로토콜: IP (Internet Protocol) 가장 대표적인 네트워크 계층의 프로토콜 하위 계층의 서비스를 이용하여 두 노드 간의 데이터 전송 경로를 확립해주는 역할 (단말장치 간 패킨 전송 서비스) IP (Internet Protocol)주소 체계 32자리 2진수로, 8자리마다 점을 찍어 구분 A, B, C, D, E 클래스로 구분하는데 각 클래스는 네트워크 부분과 호스트 부분으로 구성 A, B, C 클래스는 맨 앞부분에 시작하는 2진수 숫자에 따라 구분 IP (Internet Protocol)주소 분류 사설 네트워크: 사설 네트워크는 공인 네트워크 주소 부족 현상을 해결하기 위해 많이 사용 네트워크 계층 프로토콜: ICMP (Internet Control Message Protocol) 호스트 서버와 인터넷 게이트웨이 사이에서 메시지를 제어 및 오류를 알려주는 프로토콜 대표적인 툴은 ping ICMP Echo Request 메시지 송신측의 전송 패킷이 목적이 노드나 라우터에 도착했는지를 확인하는 데 사용 네트워크 계층 프로토콜: IGMP (Internet Group Management Protocol) 멀티캐스트에 관여하는 프로토콜로 멀티캐스트 그룹을 관리하는 역할 유니캐스트(Unicast) - 일반적, 브로드캐스트(Broadcast), 멀티캐스트(Multicast) - 중간 / 효율높음 IP 멀티캐스트 주소는 D 클래스 주소 대역(244.0.0.1 ~ 239.255.255.255)으로 규정 네트워크 계층 관련 장비: 라우터 네트워크의 대표적인 장비, 게이트웨이라고도 함 논리적으로 분리된 둘 이상의 네트워크를 연결 로컬 네트워크에서 브로드캐스트를 차단하여 네트워크를 분리 패킷이 목적지까지 가장 빠르게 보내는 길잡이 역할 정적 라우팅 관리자 권환으로 특정 경로를 통해서만 패킷이 지날 수 있도록 설정 네트워크 변경사항이 발생하면 라우팅 테이블을 수동으로 직접 고쳐야 함 보안이 중요한 경우 선호 동적 라우팅 라우터가 네트워크 연결 상태를 스스로 파악하여 최적의 경로를 선택해 전송 네트워크 연결 형태가 변경되어도 자동으로 문제를 해결 네트워크 계층 구조: 전송 계층4계층: 전송 계층(Transport Layer) 프로토콜(TCP, UDP)과 관련된 계층으로 오류 복구와 흐름 제어 등을 담당, 두 시스템 간에 신뢰성 있는 데이터를 전송 네트워크 계층에서 온 데이터를 세션 계층의 어느 어플리케이션에 보낼 것인지 판독, 전송할 경로(Port, 포트)를 선택 네트워크 계층에서 전송한 데이터와 실제 운영체제의 프로그램이 연결되는 통신 경로라고 할 수 있음 대표 프로토콜은 TCP(Transmission Control Protocol) TCP가 가진 주소를 포트(Port)라 하며 0~65532(216-1)번까지 존재 -~1023번(1,024)d을 잘 알려진 포트(Well Known Port)라고 부름 (보통 0번 포트는 사용하지 않음) 포트 주소 수신지 컴퓨터까지 전송하려면 IP 주소와 물리 주소의 포트주소도 필요함! 인터넷 통신의 최종 목적은 한 프로세스가 다른 프로세스와 통신할 수 있도록 하는 것 즉 포트는 Tcp가 상위 계층으로 데이터를 전달하거나 상위 계층에서 TCP로 데이터를 전달할 때 상호 간에 사용하는 데이터의 이동 통로를 말함 전송 계층 프로토콜: TCP(Transmission Control Protocol) 연결 지항형 프로토콜 IP와 함께 통신을 하는 데 반드시 필요한 가장 기본적인 프로토콜 TCP의 특징 높은 신뢰성 가상 회선 연결 방식 연결의 설정과 해제 데이터 체크섬 시간 초과와 재전송 데이터 흐름 제어 연결 설정 과정(Three-Way Handshaking) 연결 해제 과정 전송 계층 프로토콜: UDP(User Datagram Protocol) 비연결 지향형 프로토콜 상대방이 보낸 응답을 확인하지 않아 네트워크에 부하를 주지 않음 데이터 자체의 신뢰성이 없어 수신한 데이터의 무결성을 보장받지 못함 UDP의 특징 비연결 지향형 네트워크 부하 감소 비신뢰성 전송된 데이터의 일부가 손실됨 네트워크 계층 구조: 세션 계층5계층: 세션 계층(Session Layer) 응용 프로그램 계층 사이의 접속을 설정 · 유지 · 종료시켜주는 역할 통신장치간의 설정을 유지하고 동기화 하는 역할 네트워크 계층 구조: 표현 계층6계층: 표현 계층(Presentation Layer) 데이터 표현 차이를 해결하려고 서로 다른 형식으로 변환하거나 공통 형식을 제공하는 계층 네트워크 계층 구조: 응용 계층7계층: 응용 계층(Application Layer) 여러가지 프로토콜에 대하여 사용자인터페이스를 제공 응용 계층(Application Layer) 관련 프로토콜들FTP(File Transfer Protocol, 20,21) 파일 전송을 위한 가장 기본적인 프로토콜 1972 년 텔넷과 함께 표준으로 제정 클라이언트와 서버가 대화형으로 통신 가능 Telnet(텔넷, 23) 사용자가 원격에 있는 서버에 로그인하도록 TCP 연결을 설정 단말기가 원격 컴퓨터 바로 옆에 있는 것처럼 직접 조작할 수 있게 해줌 POP3 &amp; IMAP POP3(110) : 메일 서버로 전송된 메일을 확인할 때 사용하는 프로토콜 IMAP(143) : POP3 와 기본적으로 같으나 , 메일을 읽은 후 메일이 서버에 남음 SMTP(Simple Mail Transfer Protocol, 25) 메일 서비스 DNS(Domain Name System, 53) 도메인 이름 주소를 통해 IP 주소를 확인할 수 있는 프로토콜 TFTP(Trivial File Transfer Protocol, 69) 파일을 전송하는 프로토콜 UDP 패킷을 사용하고 , 인증 기능을 제공하지 않음 HTTP( HyperText Transfer Protocol, 80) 인터넷을 위해 사용하는 가장 기본적인 프로토콜 네트워크 장비 네트워크 장비: 스위치 종류 L2 스위치: MAC 정보 기반 네트워크 통신 지원 L3 스위치: IP 정보 기반 네트워크 통신 지원 L4 스위치: IP 정보 + 포트정보 기반 네트워크 통신 지원 L7 스위치: Application Data 기반 네트워크 통신 지원 기본적인 네트워크의 구성","link":"/2021/09/14/dataNetwork-W2/"},{"title":"[강의정리] 데이터통신과네트워크 Overview","text":"네트워크의 이해네트워크의 사전적 의미 여러한 통신설비를 통해서 두대 이상의 컴퓨터를 서로 연결하는것 다수의 컴퓨터를 네트워크로 연결했을 때 얻을 수 있는 이점 데이터 공유가 용이함 (NAS) 주변장치 공유 (프린터) 눙률적인 통신 (메일) 근거리통신 (Local Area Network)근거리 통신망 (LAN, Local Area Network) 한 건물이나 학교 내 캠퍼스처럼 비교적 가까운 지역에 한정된 통신망 광역통신 (Wide Area Network)광역 통신망 (WAN) 두 개 이상의 근거리 네트워크가 넓은 지역에 걸쳐 연결되어 있는 것 WAN은 하나의 국가 또는 국가와 국가 간을 연결하는 매우 범위가 넓은 네트워크 우리가 매일 사용하는 인터넷 통신방식클라이언트/서버 시스템 다른 컴퓨터에 데이터 전송 서비스를 제공하는 컴퓨터를 ‘서버’라 하고, 서버에서 보내주는 데이터서비스를 수신하는 컴퓨터를 ‘클라이언트’라고 한다. 유니캐스트 네트워크에서 가장 많이 사용하는 방식 서버와 클라이언트 간의 일대일(1:1) 통신 방식 클라이언트의 IP주소와 MAC주소가 필요 브로드캐스트 로컬 LAN(라우터로 구분된 공간)에 있는 모든 네트워크 단말기에 데이터를 보내는 방식 서버와 클라이언트간에 일대모두(1:모두)로 통신하는 데이터 전송 서비스 브로드캐스트의 MAC주소는 FF-FF-FF-FF-FF-FF로 미리 정해져 있다. 다른 라우터를 찾거나, 라우터끼리 데이터를 교환하거나, 서버가 서비스를 제공하려고 모든 클라이언트에게 알릴 때 등 여러 상황에서 사용 하지만 불특정 다수에게 전송되는 서비스라 수신을 원치않는 클라이언트도 수신하므로 네트워크 성능 저하를 가져올 수 있다. 멀티캐스트 브로드캐스트는 데이터를 무조건 CPU로 전송하기 때문에 컴퓨터 자체의 성능을 떨어뜨림 멀티캐스트는 전송하려는 특정 그룹에게만 한 번에 전송할 수 있기 때문에 유니캐스트처럼 반복해서 보낼 필요가 없고, 브로드캐스트처럼 전송받을 필요가 없는 컴퓨터에 보내지 않아도 됨 프로토콜 (Protocol)프로토콜에 대한 이해 본래의 의미는 외교에서 의례 또는 의정서 톰 마릴이 컴퓨터와 컴퓨터 사이에서 메시지를 전달하는 과정이라 정의 프로토콜의 3가지 요소 구문(Syntax): 데이터의 구조나 포멧을 의미 의미(Semantics): 전송되는 데이터의 각 부분이 무엇을 뜻하는지를 알 수 있게 미리 정해둔 규칙(데이터 자체뿐만 아니라 오류 제어, 동기 제어, 흐름 제어를 포함) 순서(Timing): 어떤 데이터를 보낼 것인지와 얼마나 빠르게 데이터를 보낼 것인지 정의 프로토콜의 기능주소 설정(Addressing) 서로 다른 시스템의 두 개체가 통신을 하는경우 필요 순서 제어(Sequence Control) 프로토콜 데이터 단위를 전송할 때 보내는 순서를 명시하는 기능(연결 지향형 (Connection-Oriented)에서만 사용) 데이터 대열의 단편화 및 재조합(Fragmentation &amp; Reassembly) 대용량 파일을 전송할 때 전송 효율이 높은 작은 단위로 나누어 전송한 뒤 전송 받은 시스템에서 이를 재조합 해야 함 어떻게 쪼갤건지, 재조합 할건지 캡슐화(Encapsulation) 데이터에 제어 정보를 추가 연결 제어(Connection Control) 연결 설정, 데이터 전송, 연결 해제에 대한 통제 수행 흐름 제어(Flow Control) 송신측 개체로부터 오는 데이터의 양이나 속도를 조절하는 기능 송신측과 수신측의 속도 차이 등으로 인한 정보 유실을 방지 오류 제어(Error Control) 두 개체에서 데이터를 교환할 때 오류가 발생할 경우, 이를 제어하는 기법 순서를 검사하거나 특정 시간 안에 받지 못하면 재전송을 요구하는 방식 동기화(Synchronization) 두 개체 간에 데이터를 전송할 때 각 개체는 특정 타이머 값이나 윈도우 크기 등을 통해 동시에 정의된 인자 값을 공유하는 것 다중화(Multiplexing) 통신 선로 하나에서 여러 시스템을 동시에 통신할 수 있는 기법 전송 서비스 우선순위 결정, 서비스 등급과 보안 요구 등을 제어하는 서비스 네트워크 계층 구조네트워크 계층화에 대한 이해 1980년대 초 ISO(International Organization for Standardization)은 여러 업체가 만든 시스템에 대해 상호 연동이 가능한 표준 네트워크 모델을 제정할 필요성을 인식 1984년 OSI(Open System Interconnection) 네트워크 모델을 발표 OSI 7계층 모델 OSI 7계층물리 계층: 1계층 실제 장치를 연결하는데 필요한 전기적, 물리적 세부 사항을 정의 물리 계층의 장치로는 허브나 리피터가 있음 데이터 링크 계층: 2계층 점대점(Point-to-Point) 사이의 신뢰성 있는 전송을 보장하기 위한 계층 CRC 기반의 오류 제어와 흐름 제어가 필요 가장 잘 알려진 예는 이더넷 네트워크 계층: 3계층 여러 노드를 거칠 때마다 경로를 찾아주는 역할 라우팅, 흐름 제어, 단편화(Segmentation/Desegmentation), 오류 제어 등을 수행 대표적인 예는 라우터임, 또한 3계층에서 동작하는 스위치를 흔히 L3 스위치라 함. 전송 계층: 4계층 양 끝단 사용자들이 신뢰성 있는 데이터를 주고받을 수 있게 하여 상위 계층이 데이터 전달의 유효성이나 효율성을 고려하지 않아도 되게 해줌. 전송 계층에서 동작하는 프로토콜 중 TCP는 연결 지향(Connetion-Oriented) 프로토콜임 세션 계층: 5계층 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공 TCP/IP 세션을 만들고 없애는 책임을 짐. 표현 계층: 6계층 시스템에서 사용되는 코드 간의 번역을 담당 표현 계층은 data의 Format(형식)을 정의함 응용 계층: 7계층 사용자나 응용 프로그램 사이에 데이터 교환을 가능하게 하는 계층 HTTP, FTP, 터미널 서비스, 메일 프로그램, 디렉토리 서비스 등을 제공 TCP/IP 4계층 OSI 7계층 vs. TCP/IP 4계층 OSI는 개념적인 모델 (실제 구현에서 반드시 지킨다고 볼 수 없음) TCP/IP 프로토콜은 OSI 모델보다 먼저 개발됨 TCP/IP 프로토콜의 계층은 OSI 모델의 계층과 정확히 일치하지 않음 두 계층을 비교할 때, 세션(Session)과 표현(Presentation) 2개의 계층이 TCP/IP프로토콜 그룹에 없다는 것을 알 수 있음 OSI 7 Layer는 장비 개발과 통신 자체를 어떻게 표준으로 잡을지 사용되는 반면에 실질적인 통신 자체는 주로 TCP/IP 프로토콜을 사용함 최근에는 TCP/IP 모델을 5계층으로 분류하기도 함 네트워크 계층 구조: 물리 계층1계층: 물리 계층(Physical Layer) 두 시스템 간에 데이터를 전송하려고 링크를 활성화하고 관리하는 전기적 · 기계적 · 절차적 · 기능적 특성 등을 정의 OSI 참조 모델 7계층 중 물리 계층은 최하위 계층인 첫 번째 계층으로, 상위 계층에서 전송된 데이터를 물리매체를 통해 다른 시스템에 전기적 신호로 전송 LAN 카드, 케이블, 허브, 라우터 등 물리적인 것과 데이터 전송에 사용하는 전압 등 기본적인 것들이 물리계층에 속함. 송신 측: 데이터 링크 계층에서 0과 1로 구성된 비트열의 데이터(프레임)을 받아 전기적 신호로 변환한 후 전송매체를 통하여 수신측에 보냄 수신 측: 송신측에서 받은 전기 신호를 0과 1로 구성된 비트열로 복원, 수신측의 데이터 링크 계층에 전송 물리 계층 관련 장비리피터(Repeater) 네트워클르 연장하기 위한 장비 불분명해진 신호 세기를 다시 증가시키는 역할 최근 리피터가 모든 네트워크 장비에 공통으로 들어가는 기능이 됨. 허브(Hub) 요즘 쓰이는 스위치의 예전 형태 허브는 스위치와 형태나 사용 방법이 같지만 패킷을 모든 곳에 똑같이 복사해서 보내는 것이 다름(스위치는 목적지에만 데이터를 전송) 네트워크 계층 구조: 데이터 링크 계층2계층: 데이터 링크 계층(Data Link Layer) 물리적 링크를 이용하여 신뢰성 있는 데이터를 전송하는 계층 네트워크를 통해 데이터를 전송할 때 전송로 역할 데이터 링크 계층은 비트를 프레임이라는 논리적 단위로 구성 시스템 간에 오류 없이 데이터를 전송하려고 **네트워크 계층에서 받은 데이터 단위(패킷)를 프레임으로 구성하여 물리 계층으로 전송 데이터 링크 계층의 물리적인 주소: 랜카드나 네트워크 장비의 하드웨어 주소(MAC 주소) 네트워크 카드의 MAC 주소는 윈도우 명령 창에서 ‘ipconfig /all’ 명령을 실행하면 ‘Physical Address’ 에서 확인 가능 리눅스 Machine의 경우 ifconfig 명령어 MAC 주소 총 12개의 16진수로 구성 앞쪽 6개는 네트워크 카드를 만든 회사(OUI: Organizationally Unique Identifier)를 뜻하고, 뒤쪽 6개는 호스트 식별자(Host Identifier)로 각 회사에서 임의로 붙이는 일종의 시리얼 같은 MAC 주소는 존재하지 않음 데이터 링크 계층 프로토콜: 이더넷 제록스의 PARC(Palo Alto Research Center)에서 1970년대에 개발한 데이터 링크 계층의 프로토콜 CSMA/CD (Carrier Sense Multiple Access/Collision Detection) 이더넷의 통신 방식 이더넷 환경에서 통신을 하고 싶을 때, Carrier Sense를 수행함 복수개의 디바이스가 동시에 통신을 시작할 때, Collision이 발생하고 이를 Detection 할 수 있음 Collision Detection이 일어난 후, 랜덤한 시간을 기다리고 다시 데이터를 보냄 데이터 링크 계층 장비브리지(Bridge) 랜(LAN)과 랜(LAN)을 연결하는 초기의 네트워크 장치 데이터 링크 계층에서 통신 선로를 따라서 한 네트워크에서 그 다음 네트워크로 데이터 프레임을 복사하는 역할 스위치 기본적으로 데이터 링크 계층에서 작동하는 스위치를 뜻함 (L2 스위치) 허브의 단점이 Collision Domain의 확대를 해결 L2 스위치는 연결된 시스템이 늘어날수록 패킷 간 충돌 때문에 매우 낮은 속도로 동작하는 더미 허브의 문제점을 해결하는 획기적인 방안 과거에는 브릿지를 통해서 Collision Domain을 나누었지만, 현재는 스위치가 인기가 많음. 스위치의 MAC 주소 테이블 시스템 간의 원활한 통신을 위해 주소 테이블을 생성하고 관리하는 역할 네트워크 계층 구조: 네트워크 계층3계층: 네트워크 계층(Network Layer) 랜(LAN)을 벗어난 통신을 하기 위해 네트워크 계층에서 IP 주소를 사용 라우팅 프로토콜을 사용하여 최적의 경로를 선택 네트워크 계층은 데이터를 패킷 단위로 분할하여 전송한 후 재결합함","link":"/2021/09/06/dataNetwork-W1/"},{"title":"[강의정리] 고급 컴퓨터수학 W1","text":"선형 대수 (Linear Algebra)스칼라 : 숫자(Magnitude)나 크기만 있고 방향을 갖지 않는 (키, 몸무게, 속력 등)벡터 : 스칼라의 배열, 크기와 방향을 가진 값 (속도 등) 공간벡터, 위치벡터..행렬 : 2차원의 배열텐서 : 임의의 차원을 갖는 배열, 좌표 변환 등으로 사용 0차 텐서, 1차 텐서, 2차 텐서, 3차 텐서 등 *","link":"/2021/09/15/AdvancedComputerMath-W1/"},{"title":"[강의정리] 알고리즘 W2","text":"Introduction to Algorithm알고리즘의 학습목표Design(설계) 알고리즘 설계하는 기법 Analysis(분석) 알고리즘을 분석, 시간/공간 복잡도 구하기 Computational Complexity(계산복잡도) 문제를 분석하여 계산적 복잡도 구하기 알고리즘의 분석시간복잡도(Time Complexity) 분석 입력 크기에 따라서 단위연산이 몇번 수행되는지 결정하는 절차(n) 표현 척도입력크기(input size) 배열의 크기, 리스트의 길이, 행렬에서 행과 열의 크기, 트리에서 마디와 이음선의 수, 그래프에서는 정점과 간선의 수단위연산(basic operation) 비교(comparison), 지정(assignment) 등 시간복잡도에 가장 크게 영향을 미치는 연산 분석 방법의 종류 모든경우 분석(Every-case analysis) 최악의 경우 분석(Worst-case analysis) 평균의 경우 분석(Average-case analysis) 최선의 경우 분석(Best-case analysis) 계산복잡도Big O 표기법정의 : 점근적 상한(Asymptotic Upper Bound)차수의 주요 성질복잡도 함수 순서 lgn, n, nlgn, n2, nj, nk, an, bnn, n!k &gt; j &gt; 2, b &gt; a &gt; 1","link":"/2021/09/15/algorithm-w2/"},{"title":"[강의정리] 알고리즘 W3 - Data Structures","text":"Data Structure ListLinked List 배열과 달리 크기를 바꿀 수 있는 자료구조 각 노드는 다음노드를 가르키는 포인터를 가짐 첫번째노드: 헤드(Head), 마지막 노드: 테일(Tail) Double Linked List 각 노드는 다음노드와 이전노드를 가르키는 포인터를 가짐 Circle Linked List Head가 Tail을 물고있는 형태의 Linked List Stack 먼저 들어간 요소가 나중에 나옴 (First-In, Last-Out: LIFO) Queue 먼저 들어간 요소가 먼저 나옴 (First-In, First-Out: FIFO) Circle QueueLinked QueueTree 나무를 닮은 구조 Root, Branch, Leaf로 이루어져 있음깊이(Depth): 루트노드에서 해당 노드까지의 경로의 길이레벨(Level): 같은 깊이를 가지는 노드의 집합높이(Height): “가장 깊은 곳”에 있는 잎노드까지의 깊이 차수(Degree): 자식 노드의 개수트리의 차수: 트리 내에 있는 노드들 가운데 자식 노드가 가장 많은 노드의 차수이진트리(Binary Tree) 모든 노드가 최대 “2 개”의 자식을 가질 수 있는 트리포화 이진 트리(Full Binary Tree) 모든 노드가 대대손손이 자식을 둘씩 가지고 있는 이진 트리완전 이진 트리 잎 노드들이 트리의 왼쪽부터 차곡차곡 채워진 트리완전 높이 균형 트리(Completely Height Balanced Tree) 루트 노드를 기준으로 왼ㅉ고 하위 트리와 오른ㅉ고 하위 트리의 높이가 같은 이진트리 Priority Queue 우선순위 속성을 갖는 데이터를 다룸 Heap 힙 순서 속성(Heap Order Property)를 만족하는 완전 이진 트리 힙 순서 속성 : 트리 내의 모든 노드가 부모 노드보다 커야 한다는 규칙 Graph인접 행렬 : 정점 끼리의 인접 관계를 나타내는 행렬","link":"/2021/10/07/algorithm-w3/"},{"title":"[강의정리] 알고리즘 week4 (merge sort)","text":"Divide-and-Conquer 분할정복식 설계전략 분할(Divide): 해결하기 쉽도록 문제를 여러 개의 작은 부분으로 나눔 정복(Conquer): 나눈 작은 문제를 각각 해결 통합(Convbine): 해결된 해답을 모음 이러한방식을 Top-Down(하향식) 접근 방법이라고 한다 Binary Search(이분검색): 재귀 알고리즘 분할: 배열을 반으로 나누어서 x가 중앙에 위치한 항목보다 작으면 왼쪽에 위치한 배열 반쪽을 선택, 그렇지 않으면 오른쪽에 위치한 배열 반쪽을 선택 정복: 선택된 반쪽 배열에서 X를 찾는다 통합: 필요없음 재귀 알고리즘(recursive algorithm)에서 모든 재귀호출이 알고리즘의 마지막(꼬리) 부분에서 이루어 질 때 꼬리 재귀호출(tail recursion)이라고 함 - 그 알고리즘은 반복 알고리즘(iterative algorithm)으로 변환하기 수월ㅋ 최악의 경우 시간복잡도 분석 단위연산: x와 S[mid]의 비교 입력 크기: 배열의 크기 n(= high - low + 1) 알고리즘에서는 단위연산으로 설정한 조건문을 while루프 내에서 2번 수행하지만, 사실상 비교는 한번만 수행(1) 어셈블리언어로는 하나의 조건 명령으로 충분히 구현 가능(2) x를 찾기 전까지는 항상 2개의 조건문을 수행하므로 하나로 묶어서 한 단위로 취급해도 됨 경우 1: 검색하게 될 반쪽 배열의 크기가 항상 정확하게 n/2이 되는 경우 시간복잡도를 나타내주는 재현식(recurrence)는 다음과 같다W(n) = W(n/2)+1, n &gt; 1이고, n = 2k(k&gt;=1)W(1) = 1이식의 해는 다음과 같이 구할 수 있다W(1) = 1W(2) = W(1) + 1 = 2W(4) = w(2) + 1 = 3W(8) = W(4) + 1 = 4W(16) = W(8) + 1 = 5…W(2k)=k+1…W(n) = lg n + 1 증명: 수학접 귀납법:귀납 출발점: n=1이면, W(1) = 1 = lg 1 + 1.귀납 가정: 2의 거듭제곱(power)인 양의 정수 n에 대해서, W(n)=lg n + 1라고 가정귀납 단계: W(2n) = lg(2n) + 1임을 보이면 된다. 재현식을 사용하면,W(2n) = W(n) + 1 = lg n + 1 + 1 = lg n + lg 2 + 1 = lg(2n) + 1 경우 2: 일반적인 경우 - 반쪽 배열의 크기는 [n/2]이 됨합병정렬(Mergesort)123456789101112void mergesort (int n, keytype S[]) { const int h = n / 2, m = n - h; keytype U[1..h], V[1..m]; if(n&gt;1) { copy S[1] through S[h] to U[1] through U[h]; copy S[h+1] through S[n] to V[1] through V[m]; mergesort(h,U); mergesort(m,V); merge(h,m,U,V,S); }} 시간복잡도 분석합병 알고리즘의 최악의 경우 시간복잡도 분석 단위연산: U[i]와 V[j]의 비교 입력크기: 2개의 입력 배열에 각각 들어있는 항목의 개수: h와 m 분석: i=h이고, j=m-1인 상태로 루프(loop)에서 빠져 나가는 때가 최악의 경우로서 (V에 있는 처음 m-1개의 항목이 S의 앞부분에 위치하고, U에 있는 h개의 모든 항목이 그 뒤에 위치하는 경우), 이때 단위연산의 실행 횟수는 h + m - 1이다. 따라서 최악의 경우 합병하는 시간복잡도는 W(h, m) = h + m - 1. 합병정렬 알고리즘의 최악의 경우 시간복잡도 분석 단위연산: 합병 알고리즘 merge에서 발생하는 비교 입력크기: 배열 S에 들어 있는 항목의 개수 n 분석: 최악의 경우 수행시간은 W(h,m) = W(h) + W(m) + h + m - 1이 된다. 여기서 W(h)는 U를 정렬하는데 걸리는 시간, W(m)은 V를 정렬하는데 걸리는 시간, 그리고 h + m - 1은 합병하는데 걸리는 시간이다. 정수 n을 2k(k&gt;=1)이라고 가정하면, h= n/2, m=n/2가 된다. 따라서 최악의 경우 재현식은:W(n) = 2W(n/2)+n-1 n&gt;1이고, n=2k(k&gt;=1)W(1) = 0 왜냐하면 합병이 전혀 이루어지지 않으므로 이 재현식의 해는 아래의 도사정리의 2번을 적용하면W(n) = O(n lg n)이 된다.","link":"/2021/10/08/algorithm-w4/"},{"title":"[강의정리] 알고리즘 W5 (quicksort, sorting algo)","text":"Quicksort 분할교환정렬(patition exchange sort)라고 불린다.12345678910111213141516171819202122void quicksort(index low, index high) { index pivotpoint; if (high &gt; low) { partition(low, high, pivotpoint); quicksort(low, pivotpoint-1); quicksort(pivotpoint+1, high); }}void partition(index low, index high, index&amp; pivotpoint) { index i, j; keytype pivotitem; pivotitem = S[low]; //pivotitem을 위한 첫번째 항목을 고른다. j = low; for(i = low + 1; i &lt;= high; i++) if(S[i] &lt; pivotitem) { j++; exchange S[i] and S[j]; } pivotpoint = j; exchange S[low] and S[pivotpoint]; //pivotitem값을 pivotpoint에 넣는다} 분석 단위연산: S[i]와 key와의 비교 입력크기: 부분배열이 가지고 있는 항목의 수, n = high - low + 1 분석: 배열의 첫번째 항목만 제외하고 모든 항목을 한번씩 비교하므로, T(n) = n - 1이다. 최악의 경우 시간복잡도 분석 단위연산: 분할 알고리즘의 S[i]와 pivotitem과의 비교 입력크기: 배열 S가 가지고 있는 항목의 수, n 분석: 이미 비내림차순으로 정렬이 되어있는 배열을 정렬하려는 경우가 최악의 경우가 됨. 비내림차순이면 첫번째(pivot)항목보다 작은 항목은 없으므로, 크기가 n인 배열은 크기가 0인 부분은 왼쪽에 오고, 크기가 n-1인 부분배열은 오른쪽에 오도록 하여 계속 쪼개진다. 따라서, T(n) = T(0) + T(n-1) - n - 1 그런데 T(0) = 0이므로 재현식은 다음과 같이 된다. T(n) = T(n-1) + n - 1, n &gt; 0이면 T(0) = 0 이 재현식을 풀면, T(n) = T(n-1) + n - 1 T(n-1) = T(n-2) + n - 2 T(n-2) = T(n-3) + n - 3 ... T(2) = T(1) + 1 T(1) = T(0) + 0 T(0) = 0 T(n) = 1 + 2 + ... + (n-1) = n(n-1) / 2 평균의 경우를 고려한 시간복잡도 분석 단위연산: 분할알고리즘의 S[i]와 pivotitem과의 비교 입력크기: 배열이 S가 가지고 있는 항목의 수, n 분석:","link":"/2021/10/10/algorithm-w5/"},{"title":"[강의정리] 고급 컴퓨터수학 W6-대면(화)","text":"Loss Function, Cost Function 모델의 예측값과 실제 값의 오차 Example of Loss FunctionMean Squared Error: 에러의 제곱 이용 계산 간편 크기에 의존적 Cross Entropy: 확률의 불확실성 수치 실제 분포를 모를때 예측가능 0일수록 출력이 확실함","link":"/2021/10/12/advCmpMath-W6-meet/"},{"title":"[강의정리] 알고리즘 W6 (Dynamic Programming)","text":"Dynamic programming Similar to divide-and-conquer small instances first, store the results, whenever we need a result, look it up instead of recomputing it. 알고리즘: Using Divide-and-Conquer 문제: 이항계수를 계산한다 입력: 음수가 아닌 정수 n과 k, 여기서 k &lt;= n 출력: bin, [n k] 123456int bin(int n, int k) { if (k == 0 || n == k) return 1; else return bin(n-1, k-1) + bin(n-1, k);} 시간복잡도 분석: 분할정복 알고리즘은 작성하기는 간단하지만, 효율적이지 않음 이유? 재귀호출(recursive call)할때 같은 계산을 반복해서 수행하기 때문 예를 들면, bin(n-1, k-1)과 bin(n-1, k)는 둘다 bin(n-2, k-1)의 결과가 필요한데, 따로 중복 계산이 됨 [n: k]를 구하기 위해서 이 알고리즘이 계산하는 항(term)의 개수는 2[n: k]-1이다. (증명을 해보자) 증명: (n에 대한 수학적 귀납법으로 증명) 귀납출발점: 항의 개수 n이 1일 때 2[n: k]-1 = 2 x 1 - 1 = 1이 됨을 보이면 된다. [1: k]는 k=0이나 1일때 1이므로 항의 개수는 항상 1이다. 귀납가정: [n: k]를 계산하기 위한 항의 개수는 2[n: k] - 1이라고 가정한다. 귀납절차: [n+1: k]를 계산하기 위한 항의 개수가 2[n+1: k] - 1임을 보이면 된다. 알고리즘에 의해서 [n+1: k] = [n: k-1] + [n: k] 이므로, [n+1: k]를 계산하기 위한 항의 총 개수는 [n: k-1]을 계산하기 위한 총 개수와 [n: k]를 계산하기 위한 항의 총 개수에다가 이 둘을 더하기 위한 항 1을 더한 수가 된다. 그런데 [n: k-1]을 계산하기 위한 항의 개수는 가정에 의해서 2[n: k-1] -1이고, [n: k]를 계산하기 위한 항의 개수는 가정에 의해서 2[n: k] - 1이다. 동적계획식 알고리즘 설계전략 Establish a recursive property (재귀 관계식을 정립): 2차원 배열 B를 만들고, 각 B[i][j]에는 [i: j]값을 저장하도록 하면, 그 값은 다음과 같은 관계식으로 계산할 수 있다. Solve an instance of the problem in a bottom-up fashion: [n: k]를 구하기 위해서는 다음과 같이 B[0][0]부터 시작하여 위에서 아래로 재귀 관계식을 적용하여 배열을 채워 나가면 된다. 결국 값은 B[n][k]에 저장된다. 문제: 이항계수를 계산한다. 입력: 음수가 아닌 정수 n 과 k, 여기서 k &lt;= n 출력: bin, [n: k] 123456789int bin2(int n, int k) { index i, j; int B[0..n][0..k]; for(i = 0; i &lt;= n; i++) for(j = 0; j &lt;= minimum(i,k); j++) if(j==0 || j==1) B[i][j] = 1; else B[i][j] = B[i-1][j-1] + B[i-1][j]; return B[n][k];} 동적계획 알고리즘의 분석 단위연산: for-j 루프 안의 문장 입력의 크기: n, ki = 0일 때 j-루프 수행 횟수 : 1i = 1일 때 j-루프 수행 횟수 : 2i = 2일 때 j-루프 수행 횟수 : 3……………i = k-1일 때 j-루프 수행 횟수 : ki = k일 때 j-루프 수행 횟수 : k + 1i = k+1일 때 j-루프 수행 횟수 : k + 1……………i = n일 때 j-루프 수행 횟수 : k + 1 따라서 총 수행횟수는:1 + 2 + 3 + … + k + (k+1) + … + (k+1) = k(k+1)/2 + (n-k+1)(k+1) = (2n-k+2)(k+1)/2 = O(nk) 그래프그래프 용어 정점(vertex, node), 이음선(edge, arc) 방향 그래프(directed graph, or digraph) 가중치(weight), 가중치 포함 그래프 (weighted graph) 경로(path) - 두 정점사이에 edge가 있는 정점들의 나열 단순경로(simple path) - 같은 정점을 두 번 지나지 않음 순환(cycle) - 한 정점에서 다시 그 정점으로 돌아오는 경로 순환그래프(cyclic graph) vs 비순환 그래프 (acyclic graph) 길이(length): the sum of weights on the path (weighted graph) the number of edges on the path (unweighted graph) Shortest Path Shortest Path: 한 도시에서 다른 도시로 직항로가 없는 경우 가장 빨리 갈 수 있는 항로를 찾는 문제 문제: 가중치 포함, 방향성 그래프에서 최단경로 찾기 Optimization problem (최적화 문제)의 정의 주어진 문제에 대하여 하나 이상의 많은 해답 후보가 존재할 때, 이와 연관된 값이 최소 또는 최대인 해답(optimal solution)을 찾아야 하는 문제 에너지 최소화 문제라고도 함. shortest Path는 Optimization problem에 속함 Brute-force algorithm(무작정 알고리즘) 한 정점에서 다른 정점으로의 모든 경로의 길이를 구한 뒤, 그들 중에서 최소길이를 찾는다. 동적계획식 설계전략 - 자료구조 그래프의 인접행렬(adjacent matrix)식 표현: W 동적계획식 설계절차 Establish a recursive property D(k-1)을 가지고 D(k)를 계산할 수 있는 재귀 관계식을 정립 D(k)[i][j] = minimum(D(k-1)[i][j], D(k-1)[i][k] + D(k-1)[k][j]) 경우 1: {v1, v2,…, vk}의 정점들 만을 통해서 vi에서 vj로 가는 최단 경로가 vk를 거치지 않는 경우, 보기: D(5)[1][3] = D(4)[1][3] = 3 경우 2: {v1, v2,…, vk}의 정점들 만을 통해서 vi에서 vj로 가는 최단 경로가 vk를 거치는 경우, 보기: D(2)[5][3] = D(1)[5][2] + D(1)[2][3] = 4 + 3 = 7 보기: D(2)[5][4] 상향식으로 k=1부터 n까지 다음과 같이 이 과정을 반복하여 해를 구한다.D(0), D(1),……,D(n) Floyd’s Algorithm I 가중치 포함 그래프의 각 정점에서 다른 모든 정점까지의 최단거리를 계산 12345678void floyd(int n, const number W[][], number D[][]) { int i, j, k; D = W; for(k=1; k &lt;= n; k++) for(i=1; i &lt;= n; i++) for(j=1; j &lt;= n; j++) D[i][j] = minimum(D[i][j], D[i][k]+D[k][j]);} Floyd’s Algorithm II 가중치 포함 그래프의 각 정점에서 다른 모든 정점까지의 최단거리를 계산, 각각의 최단경로를 구하라. 1234567891011121314void floyd2(int n, const number W[][], number D[][], index P[][]) { index i, j, k; for(i=1; i &lt;= n; i++) for(j=1; j &lt;= n; j++) P[i][j] = 0; D = W; for(k=1; k &lt;= n; k++) for(i=1; i &lt;= n; i++) for(j=1; j &lt;= n; j++) if(D[i][k] + D[k][j] &lt; D[i][j]) { P[i][j] = k; D[i][j] = D[i][k] + D[k][j]; }} 최단경로의 출력1234567void path(index q,r) { if(P[q][r] != 0) { path(q, P[q][r]); count &lt;&lt; &quot;v&quot; &lt;&lt; P[q][r]; path(P[q][r], r); }} 최적의 원칙 어떤문제의 입력에 대한 최적해가 그 입력을 나누어 쪼갠 여러 부분에 대한 최적 해를 항상 포함하고 있으면 그 문제는 최적의 원칙(the principle of optimality)이 적용된다 라고 한다. Optimal Binary Search Trees definition binary search tree Ordered set Each node contain one key The keys in the left subtree are less than or equal to the key in that tree Depth - number of edges from the root balanced - if the depth of the 2 subtrees of every node never different by more than 1 optimal - the average time it takes to locate a key is minimized 123456789101112131415void optsearchtree(int n, const float p[], float&amp; minavg, index R[][]) { index i, j, k, diagonal; float A[1...n+1][0..n]; for(i=1; i&lt;=n; i++) { A[i][i-1] = 0; A[i][i] = p[i]; R[i][i] = i; R[i][i-1] = 0; A[n+1][n] = 0; R[n+1][n] = 0; for(diagonal=1; diagonal &lt;= n-1; diagonal++) for(i=1; i&lt;=n-diagonal; i++) { j = i + diagonal; A[i][j] = minimum(A[i][k-1] + A[k+1][j]) + R[i][j] = a value of k that gave the minimum; } minavg = A[1][n]; }} The Traveling Salesperson Problem Problem Definition Determine a shortest route that starts at the salesperson’s home city, visits each of the cities once, and ends up at the home city Adjacent matrix W V = set of all the vertices A = a subset of V D[vi][A] = length of a shortest path from vi to v1 passing through each vertex in A exactly once Length of an optimal tour = minimum(W[1][j] + D[vj][V - {v1, vj}]) ```Cvoid travel(int n, const number W[][], index P[][], number&amp; minlength) { index i, j, k; number D[1..n][subset of V-{v1}]; for(i=2; i&lt;=n; i++) D[i][0] = W[i][1]; for(k=1; k&lt;=n-2; k++) for(all subsets A V-{v1} containing k vertices) for(i such that i!= 1 and vi is not in A) { D[i][A] = min(j:vj A)(W[i][j]+D[j][A-{vj}]); P[i][A] = value of j that gave the minimum; } D[1][V-{v1}] = min(2&lt;=j&lt;=n)(W[1][j] + D[j][A-{v1,vj}]); P[1][V-{v1}] = value of j that gave the minimum; minlength = D[1][V-{v1}]}","link":"/2021/10/17/algorithm-w6/"},{"title":"[강의정리] 생명정보 week7 대면정리","text":"조원: 허주미, 홍지윤발표 주제 선택","link":"/2021/10/14/infoScience-W7-meet/"},{"title":"[강의정리] 데이터통신과네트워크 Computer Network and the Internet","text":"What’s the Internet“nuts and bolts” view billions of connected computing devices: hosts = end systems running networks apps communication links fiber, copper, radio, stellite transmission rate: bandwidth packet switches: forward packets (chunks of data) routers and switches Internet: “network of networks”protocols control sending, receiving of message e.g., TCP, IP, HTTP, … Internet standards Internet Engineering Task Force (IETF) 에서 Request for comment (RFC)라는 표준 문서들을 개발함 A service viewinfrasturcture that provides services to applications: Web, VoIP, email, games, e-commerce, social nets, … Socket interface allows sending and receiving app programs to “connect” to Internet provides service options, analogous to postal service What’s a protocol?network protocols: machine rather than humans three way handshaking protocols define format, order of messages sent and received among network entities, and actions taken on message transmission, receipt Network edgeA closer look at network structrueNetwork edge (종단 시스템) hosts: clients and servers Access networks Home, Enterprise, Mobile, …Physical media wired, wireless communication links Access networks and pysical mediaHow to connect end systems to end router? residential(Home) access networks institutional access networks mobile access networks keep in mind: bandwidth (bits per second) of access network? (속도) shared or dedicated? (나만쓰는가?) Home AccessHome Access: DSLDigital Subscriber Line (DSL) 전화선을 이용한 통신 Home Access: Cable Internet AccessHFC: hybrid fiber coax (동축 케이블)Coaxial and fiber cables attach homes to ISP router fiber와 Coaxial 동시에 사용 Home Access: FTTHFiber to the home fiber만 사용 Home Access: A typical home network Enterprise accessEnterprise access: EthernetPhysical mediaPhysical media: Twisted-Pair Copper Wire Unshielded twisted pair (UTP) Shielded twisted pair (STP) Pysical media: Radio no physical “wire” Network core Mesh of interconnected routers Packet-switching Message는 application이 원하는 데이터를 포함 Message를 잘게 쪼갠게 packets Packet들이 Communication link로 이동할때 transmission rate기반으로 이동 패킷의 크기는 L bits, 전송 속도는 R bits/sec Packet-switching: Store-and-Forward 저장하고 전달 Ex) L = 7.5 Mbits, R = 1.5 Mbps, one-hop transmisson delay = 5 s End to End Delay = 2L/R 3개의 패킷을 보내는 시간 L/R시간, 첫번째 패킷이 라우터에 도착 2L/R시간, 첫번째 패킷이 목적지 도착, 두번째 패킷 라우터 도착 3L/R시간, 두번째 패킷이 목적지 도착, 세번째 패킷 라우터 도착 4L/R시간, 세번째 패킷이 목적지 도착 하나의 패킷을 N개의 링크가 있는 곳으로 보내는 End to End 딜레이 (N links (eash of rate R), N-1 Routers) Dend-to-end = N X (L/R) Queuing Delays and Packet LossQueuing and Loss: 도착하는 패킷보다 보내는 패킷이 느릴경우 딜레이 + 공간 꽉차면 Loss까지 생김 Forwarding and Routing Forwarding: input에서 output으로 움직이는것 Routing: 어디로 갈지 정해주는것 Circuit switching 데이터 회선이 정해지고 회선단위로 데이터를 주고받음 frequency-division multiplexing (FDM) - 주파수분할time-division multiplexing (FDM) - 시분할 Silend Period -&gt; 네트워크 자원낭비로 이어짐 Packet Switching vs. Circuit switching Packet switching allows more user to use network 1 Mb/s link each user: 100 kb/s when “active” the probability that a specific user is active is 0.1 circuit switching: support only simultaneous 10 users (1 Mbs/ 100 Kbps) Packet switching: With 35 users, probability &gt; 10 active at same time is less than 0.0004 35C11(0.9)24(0.1)11 &lt; 0.0004 Packet switching이 좋지만, packet delay나 loss가 발생할 수 있음 reliable한 데이터 전송이 필요 Network of networks End systems은 access ISPs (Internet Service Providers) Delay, Loss, Throughput in NetworksFour sources of packet delay Total nodal delay (dnodal) nodal processing delay (dproc), queuing delay (dqueue), transmission delay (dtrans), propagation delay (dprop) dproc: nodal processing check bit errors determine output link typically &lt; msec dqueue: queueing delay 라우터 개수에 의존 가장 중요 dtrans: transmission delay L: packet length (bits) R: link bandwidth (bps) dtrans = L/R dprop: propagation delay d: length of physical link s: propagation speed (통신매체에 따라 다름) dprop = d/s Transmission delay vs. Propagation delayCaravan analogy cars “propagate” at 100 km/hr toll booth takes 12sec to service car (bit transmission time) 2번째 톨게이트까지 가는 시간? 첫번째 톨게이트 12*10 = 120s 100km 가는 시간 = 1hr A: 62 min Queueing delay R: link bandwidth (bits / sec) L: packet length (bits) a: average packet arrival rate (packets/sec) La/R: traffic intersity La/R이 0에 가까우면: 딜레이가 거의 없음 La/R이 1에 가까우면: queueing delay가 커짐 La/R이 1보다 크면: 거의 무한대의 딜레이 Packet loss 버퍼가 가득 차면 loss 됨 End-to-End Delay N-1개의 라우터가 있을때 End-to-End Delay = N x (dproc+dtrans+dprop) Throughtput(처리량) Networks under attack: SecurityNetwork security","link":"/2021/10/20/dataNetwork-Chapter1/"},{"title":"[연습문제] 데이터통신과네트워크 Computer Network and the Internet","text":"2020-1:Host A 와 Host B 가 30,000 km 떨어진 곳에 위치하고 있고 R=5Mbps 의 속도의 네트워크 링크로연결되어져 있다 해당 네트워크의 propagation delay 는 𝟐.𝟓×𝟏𝟎^𝟖 meters/sec 이다Host A 에서 Host B 로 1,000,000 bits 의 파일을 분할없이 한번에 보낸다고 가정했을 경우 파일을보내는 시간동안 네트워크 링크에 존재하는 최대 비트 수는 얼마인가(네트워크 링크는 H ost A 와 Host B 만 사용하는 링크임 , Mega = 10^6) transmission delay: 0.2sprop delay: 0.12s600,000 bits 2020-2:네트워크를 통해 사이즈가 큰 데이터를 보낼 때 일반적으로 해당 데이터를 작은 사이즈의패킷으로 쪼갠 후 보내게 된다 해당 패킷들을 받는 수신자는 수신한 패킷들을 재조합 하여데이터 원본을 수신한다 이러한 과정을 message segmentation 이라고 부르기도 한다아래 그림은 message segmentation 이 없는 데이터 전송과 message segmentation 이 적용된데이터 전송을 나타내고 있다 Source 에서 Destination 사이에는 스위치가 2 개가 존재하고 ,Source 가 Destination 으로 보내려는 데이터 의 크기는 𝟏.𝟐×𝟏𝟎^𝟖 bits 이다 네트워크 링크 전송속도는 R=4Mbps 일 때 아래 물음에 답하시오 propagation, queuing, and processing delays 는무시한다 1 - Message segmentation 이 없는 데이터 전송 (위 그림의 (a)) 를 고려했을 때 Source 에서 Destination 까지 전체 데이터를 보내는데 걸리는 시간은 얼마인가? 3*L/R = 3 * 1.2 * 10^8 / 4 * 10^6 = 3 * (1.2 * 10^2 / 4) = 3 * 0.3 * 10^2 = 3 * 30 = 90s 2 - 전체 데이터가 1200 개의 패킷으로 나누어지고 각 패킷의 길이는 100,000bit 라고 가정해보자 Message segmentation 가 적용된 데이터 전송 (위 그림 의 (b)) 를 고려했을 때 Source 에서 Destination 까지 첫번째 패킷을 보내는데 걸리는 시간은 얼마인가? 100,000 / 5,000,000 = 1/50 = 0.02s, 0.02s * 3 = 0.06s 3 - 전체 데이터가 1200 개의 패킷으로 나누어지고 각 패킷의 길이는 100,000bit 라고 가정해보자 Message segmentation 가 적용된 데이터 전송 (위 그림 의 (b)) 를 고려했을 때 Source 에서 Destination 까지 전체 패킷 총 1200 개의 패킷 을 보내는데 걸리는 시간은 얼마인가? 하나의 패킷이 걸리는 시간 0.6s, 하나의 구간을 통과하는 시간 0.2s, 3개를 동시에 하므로 1200 * 0.2s = 240s - 0.4s = 239.6s 4 - message segmentation 장단점 장점: message를 나눠서 보내면 중간에 라우터에서도 동시에 전송을 할 수 있어서 시간이 짧아짐 단점: 패킷이 중간에 없어질 수 도있음","link":"/2021/10/21/dataNetwork-Chapter1Q/"},{"title":"[강의정리] 데이터통신과네트워크 Application Layer","text":"Principles of network applicationsApplication architectures client-server peer-to-peer Client-server architecture server: always-on host permanent IP address clients: communicate with server may be intermittently connected do not communicate directly P2P architecture No always-on server Processes communicating Process: program running within a host 같은 host 에서, inter-process communication을 통하여 두개의 프로세스가 통신 Sockets Process sends/receives messages to/from its socket Socket analogous to door Addressing processes Identifier includes both IP address and port numbers associated with process on host. Example port numbers: HTTP server: 80 mail server: 25 to send HTTP message to usaint web server: IP address: 203.253.31.114 port number: 80 App-layer protocol defines Types of messages exchanged, E.g., request, response Message syntax 구역 나누기","link":"/2021/10/21/dataNetwork-Chapter2/"},{"title":"[강의정리] 데이터통신과네트워크 Transport Layer","text":"Transport-layer servicesTransport vs. Network layer Network: hosts 사이 Transport: processes 사이 Internet transport-layer protocols Reliable in-order delivery -&gt; Transmission Control Protocol(TCP) Unrealiable, unordered delivery -&gt; User Datagram Protocol (UDP)","link":"/2021/10/21/dataNetwork-Chapter3/"},{"title":"algorithm-w8","text":"","link":"/2021/11/18/algorithm-w8/"},{"title":"[강의정리] 데이터통신과네트워크 Transport Layer 기말","text":"Congestion control Congestion: 너무 많은 소스에서 너무 많은 데이터를 빠르게 네트워크로 보낼 경우 네트워크가 처리할 수 있는 허용 용량(band width)을 넘어 혼잡 발생 Flow control과 다름 Flow control: 상대방이 데이터를 받을 수 있을 때 그 허용량만큼 보내주는것 Congestion control: 네트워크 관점에서 데이터가 많아지면 그것을 조절 선제 조건: 패킷 로스 발생 큐잉 딜레이가 늘어남 Congestion: scenario 1 two sender, two reiciver one router, inf buffer output link capacity: R (출력 링크 용량) 패킷이 유실되도 no retransmisson 람다in R/2씩 보내도 람다out R/2 딜레이관점에선 람다in이 증가할수록 딜레이는 기하급수적으로 증가 Congestion: scenario 2 one router, fin buffers sender retransmission of timed-out packet application-layer input = application-layer output tranport-layer input includes retransmissions 이상적인 상황: perfect knowledge sender는 buffer에 유효공간이 있을 때만 data를 보냄 람다’in = 람다out loss packets는 lost 될수있음, 라우터에서 버퍼가 꽉찼을때 드랍 sender는 패킷이 유실된걸 알때 다시 보냄 람다’in &gt;= 람다out 현실적인: 중복패킷 queueing delay 때문에 timeout 발생후 재전송 최악의 경우 람다’in/2 = 람다out costs of congestion: network congestion이 많아지면 필요하지 않는 재전송이 많아짐 Congestion: scenario 3 four senders multihop paths timeout/retransmission 존재 TCP congestion control: End-to-end congestion control: 데이터가 로스가 발생하거나 속도가 느려지면 보내는양 조절 Network-assisted congestion control: 라우터들이 네트워크 복잡도 측정, 유저한테 알려줌 Sender가 transmission rate 정해두고 증가, loss가 생기면 조절 congestion window, cwnd 매 RTT(round trip time)마다 1MSS(maximum segment size)만큼 증가 로스가 발생하면 반으로 줄임 TCP Congestion control: sender 측에서 돌아감 sender에서는 window 2개 (cwnd, rwnd(recived window)) LastByteSent-LastByteAcked&lt;=min(cwnd, rwnd) TCP sending rate: cwnd/RTT bytes/sec TCP Congestion control algorithm slow start congestion avoidance fast recovery Slow start connection이 시작되면 TCP의 sending rate를 loss가 처음 발생할 때까지 1MSS단위로 증가 every RTT 마다 sending rate가 2배씩 증가됨 initial rate가 작지만, exponentially fast(기하급수적으로 빠르게)하게 증가 Congestion Avoidance ssthresh: congestion avoidance를 시작하는 시점(마지막 congestion이 발생했을 때 기점의 sending rate 절반) Fast Recovery cwnd size를 duplicate ACKs의 갯수만큼 증가 필수적인건 아님 TCP Fairness K TCP 세션, Bandwidth R 각각 평균 rate R/K Explicit Congestion Notification (ECN) Network-assisted congestion control: ECN 비트: 라우터가 패킷이 혼잡하면 설정해줌","link":"/2021/11/26/dataNetwork-transport/"},{"title":"[강의정리] 데이터통신과네트워크 Network Layer","text":"Network-layer function Forwarding: 여러개의 패킷을 매칭되는 output 포트로 연결시켜주는 역할 Routing: 포워딩한 패킷들이 정해진 목적지까지 가는것 예시: 여행 포워딩: 교차로에서 어디로갈지 결정 라우팅: 출발점에서 도착점까지 어떤 경로로 갈지 정하는것 Data plane router input port로 어떠한 데이터가 왔을 때 output port로 포워딩을 해주는것을 결정하는 역할 control plane datagram이 왔을때 어떤경로로 routing 해줄지 결정 2가지 control-plane approaches: traditional routing algorithm: 패킷에서 최선의 결정으로 라우팅 software-defined networking(SDN): 중앙에서 소프트웨어적으로 라우팅을 변경해줌 Tanditional Approch Routing Alogrithm: forwarding table을 만들어줌 (control plane) table로 forwarding 시켜줌(data plane) SDN 중앙서버에 RemoteController 존재. 각Router에 Control agents로 컨트롤 Router architectureInput port functions line termination: 아날로그신호 -&gt; 디지털 link layer protocol: link layer에서 작업 decentralized switching lookup: 어느 output port로갈지 결정 forwarding: output 출력 port 설정 queueing: 나가는 속도보다 들어오는 속도가 빠르면 queueing destination-based forwarding: 패킷에서 destination 해더 정보를 보고 어디로 보낼지 결정 generalized forwarding: 헤더의 여러 정보들을 보고 결정 특수한 경우에만 사용 Switch fabric 경로들이 엉킬수도 있음 (fabric: 직물) destination-based forwarding destination IP Address 주소를 기반으로 어떤 Output Port로 데이터를 보낼 것인지를 결정하는 forwarding algorithm longest prefix matching 원하는 부분만 정하고 나머지부분은 와일드카드로 설정하는 방법 Switching Switching fabric: 라우터의 핵심 memory: 과거방식, 패킷을 받고 메모리에 보관후 포워딩 테이블을 보고 보냄, 인터럽트 기반. bus: 레이블을 붙여서 버스에 보냄, 자신의 레이블이면 받아서 처리, 아니면 드롭 crossbar: interseption마다 on off 스위치 있음 Input port queueing Head-of-the-Line(HOL) blocking: 앞선 패킷(head)이 나가지 않았을 때 뒤에있는 패킷들도 계속 기다리는 현상 Output port queueing line termination에서 보내는 속도가 switch fabric에서 들어오는 속도보다 느릴 때 datagram buffer에서 queueing 발생 scheduling discipline: 우선순위 기발 패킷 스케쥴링 Schedule mechanisms (스케쥴링 매커니즘) FIFO 스케쥴링: 먼저 들어온 패킷을 먼저 보냄(FCFS) priority scheduling (우선순위 스케쥴링) 여러개 큐중 우선순위가 높은 큐의 패킷부터 전송 우선순위가 낮은 큐는 끝없이 밀릴 수 있음: 가중치를 줘서 우선순위를 가변적으로 만듬 Round Robin (RR) 각 클래스마다 한번씩 보냄 Weighted Fair Queueing (WFQ) Round Robin 방식에서 사용 각 클래스에 사이클의 weight를 줌 Internet network layer routing protocols -&gt; forwarding table IP protocol IP fragmentation, reassembly network links have MTU(max transfer size) fragmentation: 큰 패킷이 MTU때문에 작게 쪼개지는것 reassembly: 쪼개진 패킷들을 합치는것 (final destination에서만 이루어짐) example 4000byte datagram MTU = 1500bytes length: 1500(1480 data field) / ID = x / fragflag = 1 / offset = 0 length: 1500(1480 data field) / ID = x / fragflag = 1 / offset = 185(1480/8) length: 1040(1020 data field) / ID = x / fragflag = 0 / offset = 370 IP addressing ip address: 32-bit interface: host/router와 physical link 사이의 connection router: multiple interface Subnets 높은 주소 비트: subnet part 낮은 주소 비트: host part ex: 233.1.1.0/24 (subnet mask: /24): 총 24비트(233.1.1)이 서브넷 IP addressing: classful addressing IP주소는 8, 16, 24비트 단위로 쪼개짐 classful addressing 문제 class C(/24)를 보면 2^8 - 2 = 254개의 호스트만 사용가능 (기업에선 매우 작은 숫자) 그렇다고 class B(/16)을 사용하면 65,634개로 너무 많음 IP addressing: CIDR CIDR: Classless Inter Domain Routing 서브넷 임의의 길이 address format: a.b.c.d/x, x는 서브넷을 의미하는 비트의 길이 Broadcasting address: 255.255.255.255 IP addresses: how to get one? hard-coded by system admin in a file DHCP(Dynamic Host Configuration Protocol): 동적으로 서버에서 주소를 가져옴 plug and play DHCP client-server scenario DHCP discover: client broadcast로 DHCP 서버가 있는지 물어봄 DHCP offer: DHCP 서버가 broadcast해줌 yiaddrr: your Internet address (너가 쓸 인터넷 주소) DHCP request: yiaddrr 사용하겠다고 broadcast 해줌 DHCP ACK: 사용해도된다 허락해줌 ISP: Internet Service Provide ISP’s block: 200.23.16.0/20 Organization 0: 200.23.16.0/23 Organization 1: 200.23.18.0/23 … Organization 7: 200.23.30.0/23 Q: ISP는 어떻게 address를 가져오나?A: ICANN: Internet Corportaion for Assigned Names and Numbers NAT: network address translation local network에서 내부 서브넷으로 통신(10.0.0/24) 외부로 나갈때는 외부에서 쓸 수 있는 주소로 바꿔줌 (138.76.29.7) 반대도 수행 용어 정리: 공인 IP 주소 (public IP address) 전 세계적으로 고유한 주소 (예: 서울시 동작구 상도동 정보과학관 102호) 사설 IP 주소 (private IP address) 주소가 고유하지 않음 (예: 624호) 사용 예: 공유기에 공인 IP 할당 후, 공유기에 연결된 다수의 컴퓨터에 사설 IP 할당 공인 IP와 사설 IP를 변환해주는것: NAT NAT: network address translation 사설 네트워크를 구축하면 특정 IP range를 ISP로부터 사올 필요 없음 모든 device에 하나의 IP 내부 사설 IP가 바뀌어도 외부에 통보필요x 내부 IP를 바꾸지 않고 ISP 변경 가능 외부에는 고정IP주소만 공개되기 때문에 보안적으로도 좋음 NAT implementation(구현) source: 자신의 사설IP와 임의의 PORT NUMBER NAT tranlation table 에 기록후 source change destination에서 도착하면 table을 보고 맞는 destination으로 보내줌 IPv6motivation (동기) 32비트 공간은 결국 부족해질것이다. IPv4의 format header에서 쓸모없는게 너무 많음 speed 증가시키기 위해 QoS(Quality of Service)를 증가시키기 위해 IPv6 datagram format Traffic class: datagram의 priority(우선순위)를 주기위한 field Flow Label: datagram의 flow가 같은 flow 인지 identify(식별) flow 개념이 정확하게 정의되지 않았음 Next header: upper layer protocol의 정보를 기입할때 사용(tcp/udp) IPv4 비교 Checksum: 속도를 올리기 위해 빠짐 Options: 필요하면 “Next header” 활용 ICMPv6: new version of ICMP 새로운 메시지 타입, e.g. “Packet Too Big” MTU가 지원하지 않는 패킷이 도착하면, 버리고 다시 작게 보내라함 Transition from IPv4 to IPv6 모든 라우터가 동시에 업그레이드 할 수 없음 “flag days”가 없음 tunneling: IPv4 dataram payload에 IPv6 datagram을 담는다. Network-layer functions two network layer functions: Forwarding: 라우터의 input에서 패킷을 라우터의 output으로 옮기는 역할 Data Plane Routing: 전체 경로 결정 source to destination Control Plane two approaches to structuring network control plane: 라우터마다 컨트롤(traditional) 중앙기관에서 컨트롤(Software defined networking) Routing protocol Routing protocol goal: “good” paths 결정 Graph abstraction of the network Graph: G = (N,E) N = set of routers = {u,v,w,x,y,z} E = set of links = {(u,v), (u,x), (v,x) …} c(x, x’) = cost of link(x, x’) cost는 bandwidth와 역관계 congestion와 역관계 cost of path(x1, x2, x3, …, xp) c(x1,x2) + c(x2,x3) + … + c(xp-1,xp) Key question: u에서 z까지 얼마나 적은 코스트를 사용하여 이동할 수 있는가?Routing alogrithm: source에서 destination까지 얼마나 효율적으로 보낼 수 있는가 Routing algorithm classification Global or Decentralized information Global: 모든 라우터들이 완벽한 topology에 대한 정보, link cost info 가짐 “link state” algorithm Decentralized: router는 물리적으로 연결된 이웃의 link cost만 알고 routing 진행 “distance vector” 알고리즘 static or dynamic static: 라우팅 알고리즘의 경로가 거의 변하지 않음 dynamic: 라우팅 알고리즘의 경로가 자주 바뀜, 빠르게 변경 link-state routing algorithm 다익스트라 알고리즘 모든 네트워크 노드들의 edge에 대해서 cost를 다 알고있음 각 라우터들이 자신과 관련된 “link state broadcast”를함 모든 노드가 같은 정보를 가짐 source에서부터 모든 경로에대한 최소 path을 구할 수 있음 forwarding table에 반영 Dijkstra’s algorithm discussion Algorithm complexity: n nodes 최대 O(n^2), 최적화해도 O(n log n) Oscillations possible: 최적화된 경로가 계속 바뀌면서 무한루프 될 수 있음. Distance vector algorithm Bellman-Ford equation dx(y) := cost of least-cost path from x to ythen dx(y) = minv{c(x,v) + dv(y)} v: x의 모든 이웃 노드 c(x,v): 이웃노드 v로 가는 코스트 dv(y): v에서 y까지 최소 거리 결국 이웃노드를 계속 탐색하면서 최소 경로를 찾아감 Dx(y) = x에서 y까지 가는 최소 코스트로 추정되는 값 x는 distance vector값을 유지 Dx = [Dx(y): y in N] node x: 이웃노드의 코스트를 알고있음 v: c(x, v) v로부터 받은 추정값도 알고있음 Dv key idea: 이웃노드들의 도움을 받아서 계산 Dx(y) = minv{c(x,v) + Dv(y)} for each node y in N Distance vector algorithm 사용될때: link cost 변경 주변 노드 Dv값 변경 Distributed(분배): 자신의 Dv가 변할 때 각 이웃노드들에게 알려줌 동작구조 - 각각의 노드들:loop wait for (이웃노드들이나 local link cost값이 변경되었을때) recompute (다시계산) 이웃들에게 Dv가 변경되면 알려줌 Distance vector algorithm: link cost changes 노드에서 local link cost가 바뀐걸 알아챔 routing info를 updates, distance vector 다시 계산 만약 Dv 가 바뀌면, 이웃에게 알림 “good news travels fast” t0: y가 link-cost 변경된걸 확인, Dv 업데이트, 이웃에게 알림t1: z는 그값을 y로부터 받음, 테비을 업데이트, z to x로 가는 최소값을 변경, 이웃에게 Dv 전달t2: y는 z의 업데이트값 전달받음, distance table 수정, 변경되는점은 없음 bad news travels slow - “무한반복” 문제link cost가 업데이트된걸 다른 노드들은 모르고 있기 때문에 생김결국 -&gt; 많이 반복해야함 -&gt; inf problem Distance vector algorithm: poisoned reverse If Z가 Y를 통해 X로 패킷을 라우팅할 때: Z로부터 X까지의 경로는 INF로 설정 하지만 단편적인 해결책 INF problem 해결 못함 Link State vs Distance Vector Message complexity LS: N nodes, E links, O(N*E) msg sent DV: 이웃노드끼리만 교환 Convergence time varies Speed of convergence(수렴 속도) LS: O(N^2) 알고리즘 O(N * E) 메시지 진동이 있을 수 있음 DV: 제각각 routing loops count-to-infinity problem Roubustness(견고성) LS: 각자 계산하기 때문에 실수하면 자신의 포워딩 테이블만 에러 DS: 이웃노드에게 잘못 계산된 Dv를 알려주면 에러가 번식함 Intea-AS routing in the Internet: OSPFMaking routing scalable (라우팅을 확장가능하게 만듬) 지금까지 배운 라우팅 - 이상적임 모든 라우터가 동일 네트워크가 “flat” Scale: 많은 destinations 지구상의 모든 destination을 가지고 routing table을 만들 수 없음 communication cost도 무한 함 Administrative autonomy (관리 자동화) 각각의 노드들의 routing을 자동화 자신의 네트워크를 컨트롤할 수 있어야함 scalable routing에대한 Internet approach Autonomous systems(AS): 라우터를 하나의 지역으로 모은것 (a.k.a. “domains”) Intra-AS routing - 하나의 도메인 내에서 라우팅 같은 지역의 호스트, 라우터 간의 라우팅 지원 모든 한 지역에 있는 라우터들은 같은 intra-domain protocol 구동 다른 AS에 있는 ㄹ라우터들은 다른 intra-doamin routing protocol 돌릴 수 있음 Gateway router: AS의 edge, 인프라들이 다른곳과 통신할 때 거쳐가는 라우터 Inter-AS routing 도매인간의 통신을 지원 Gateway가 inter-domain routing 지원 Interconnected ASes Forwarding table = Intra-AS Routing algorithm + Inter-AS Routing algorithm intra-AS: 하나의 AS 안에서 destinations 결정 inter-AS &amp; intra-AS: AS 밖에 있는 destinatons 결정 Inter-AS tasks gateway router에서 Inter-AS 업무 수행 AS2와 AS3를 어떤 데스크로 연결할 수 있는지 어디로 가야하는지 AS1의 모든 라우터에 전달 Inter-AS Routing interior gateway protocols (IGP) 주로 사용되는 intea-AS routing protocols: RIP: Routing Information Protocol OSPF: Open Shortest Path First IS-IS (Intermediate System to Intermediate System) protocol: OSPF랑 유사 IGRP: Interior Gateway Routing Protocols (Cisco에서 2016까지 사적으로 사용) OSPF (Open Shortest Path First) 표준: publicly available link-state algorithm 기반 link state packet을 뿌려야함 각 노드에 topology map을 만들 수 있어야함 라우터에서 다익스트라 알고리즘 구현 OSPF를 돌리는 라우터들은 항상 AS의 모든 라우터들에게 link-state를 광고해야함 IS-IS routing protocol: 다익스트라기반, OSPF랑 유사 Large domains 에서는 Hierarchical(계층적) OSPF two-level hierarchy: local area, backbone area 내에서만 link-state advertisement를 해줌 각각의 노드들은 detailed한 area topology를 알고있음; 다른 도메인으로 이동하는 경로를 알고있음 Area border routers: 자신의 area에 있는 네트워크들의 정보를 취합해서 다른 area border routers에게 advertise해줌 Backbone routers: Backbone router들 끼리 OSPF 라우팅을 할 수 있음 Boundary routers: 다른 AS 시스템이랑 연결 Internet inter-AS routing: BGP BGP (Border Gateway Protocol): inter-domain routing에서 사용하는 표준과 같은 형태 이것을 통해 인터넷의 모든 노드들이 데이터를 주고 받음 BGT는 AS에게 2가지 규격 제안: eBGP (External BGP): AS간의 메시지 교환 iBGP (Internal BGP): 하나의 AS안에 있는 routers끼리 메시지 교환 BGP는 특정 subnet에 자신의 존재를 알려주는 protocol BGP basics BGP session: TCP connection을 통해서 BGP messages 교환 다른 지역에 있는 network 들에게 자신의 존재를 알리는 역할 (path vector) Path attributes &amp; BGP routes 어떤식으로 BGP가 자신을 홍보할까 prefix + attributes = “route”prefix: CIDRized prefixes(subnet) E.g. 138.16.68/22 two important attributes: AS-PATH: 전체 경로를 나타냄 NEXT-HOP: 옆에 어떤 AS가 있는지 나타냄 Policy-based routing: Policy에 의하여 경로 결정 BGP messages TCP connection을 통해서 데이터를 주고받음 BGP messages: OPEN: BGP peer을 remote하는 TCP connection 오픈 UPDATE: 새로운 path를 광고 KEEPALIVE: 업데이트가 없을때 연결 유지 NOTIFICATION: 이전 msg에 오류 보고, connection을 닫을때도 사용 BGP route selection 라우터들은 destination AS에 대한 하나 이상의 경로를 학습 선택 기준: local 기본 설정 값 속성: 정책 결정 shortest AS-PATH closest NEXT-HOP router: hot potato routing 추가 기준 Hot Potato Routing intra-domain에서 비용이 가장 적은 local gateway 선택 Why different Intra-, Inter-AS routing? Policy: inter-AS: admin은 traffic을 cotrol하고 싶고, 누가 들어오는지 조절하기 때문에 중요 intra-AS: single admin이므로 별로 중요하지 않음 Scale: hierarchical routing을 사용, traffic을 줄임 Performance: intra-AS: performance에 focus 할 수 있음 inter-AS: 성능보단 policy가 더 중요","link":"/2021/12/07/dataNetwork-network/"},{"title":"[강의정리] 데이터통신과네트워크 Link Layer","text":"Link layer: Introduction data-link layer: datagram을 서로 인접한 노드간에 전달해주는 책임을 가지고 있는 레이어 Links: 인접한 노드들을 따라서 communication channels를 연결 wired links wireless links LANs Layer-2 packet: frame Encapsulates datagram (데이타그램 캡슐화) Link layer services Framing: datagram을 frame로 만들고, header와 trailer를 붙임 Link access: share해서 사용할때 어떻게 나눠쓸건지 결정 “MAC” address in frame headers, source와 destination을 식별하는데 사용됨 IP address와 다름 인접한 노드 사이에 신뢰성있는 데이터 전송 Wireless links: error가 많음 드물게 low bit-error link 사용 Error detection: 신호 감소, 노이즈에 의한 에러 감지 Error correction: receiver는 retransmisson에 의존하지 않고 비트오류를 식별한후 수정함 Link layer 구현되있는 곳? Network interface 카드 Adaptors Adaptors communicating sending side: datagram 캡슐화, frameing error checking bits, rdt등등 추가 receiving side: 에러, rdt등등 확인 문제가 없으면 datagram를 추출해서 위로 보냄 Error detection EDC = Error Detection and Correction bits Error detection 100% 신뢰되진 않음 하지만 거의 놓치지 않는다 EDC가 커질수록 detection과 correction이 쉬워짐 Parity checking single bit parity: detect single bit errors parity bit에 1의 개수가 짝수인지 홀수인지 확인 two-dimensional bit parity: detect and correct single bit errors Row와 column에서 짝수 개수 확인, 에러 correction 가능 Checksum: 에러를 체크하는데 사용되는 함수 통칭 Sender send Msg with Checksum Value(CV) Receiver check CV with Checksum Checksumming Methods Cyclic redundancy check (CRC) error-detection coding으로 더 powerful d bits(Data bits) + r bits(CRC bits) CRC bits: D*2^r % G Multiple access links, protocols 두가지 타입의 network links: point-to-point link: single sender, single receiver broadcast link (shared wire or medium): multiple sending and receiving Multiple access protocols single shared broadcast channel 노드들에 의해서 동시에 데이터를 보낼 수 있어야함: interference node가 동시에 signal을 보내려 하면 collision 발생 Multiple access protocol node들이 channel을 share 하고 있을 때 어떤 노드가 먼저 보낼지 결정 알고리즘은 모든 노드들에게 분산된 상태에서 구동되야함 Channel sharing에 관한 communication은 channel 자체를 사용해야함 조정을 위해 out-of-band channel 사용하면 안됨 Multiple access protocol에 대한 이상적인 상황 Given: broadcast channel of rate R bps 원하는 특성 하나의 노드가 데이터를 쓸 때, sending rate: R M개의 노드와 share할 때, send average rate: R/M Fully decentralized(완벽한 탈중앙화): transmission을 조정하는 특별한 노트 X 네트워크 시간동기화 가정 X simple MAC (Media Access Control) protocols Three broad classes: channel partitioning 채널을 작은 “조각”단위로 쪼개서 사용(time slots, frequency, code) random access 채널을 나누지 않고, 충돌이 일어나면 random한 delay로 대기 “taking turns” 번갈아가면서 사용, 공평하지만 비효율적 Channel partitioning MAC protocols: TDMA TDMA: time division multiple access 시분할방식, 시간을 n-slot으로 나눠서 사용 노는 slot이 생길 수 있으므로 비효율적 Channel partitioning MAC protocols: FDMA FDMA: frequency division multiple access 주파수 간격으로 데이터를 쪼갬 Random access protocols node가 패킷을 보낼 때 전체 채널 send rate R 사용 노드간의 사전 조절은 X 두개 이상의 노드가 동시에 사용하면 -&gt; collision Random access MAC protocol 특징: 어떻게 충돌을 detect 할건지 충돌이 일어났을 때 어떻게 recover 할 건지 (e.g., via delayed retransmissions) Examples of random access MAC protocols: slotted ALOHA ALOHA CSMA, CSMA/CD, CSMA/CA Random Access protocols: Slotted ALOHA 가정 all frames same size 동등한 사이즈로 쪼갠 time divided slots node가 slot 시작시간에 바로 transmit을 할 수 있음 모든 노드들은 동기화 되있음 2개 이상의 node가 하나의 slot에서 데이터를 보내려 하면, 모든 nodes가 충돌을 detect 작업 노드가 새로 보내야되는 frame이 있으면, 다음 slot에 transmits if no collision: node는 새로운 frame을 다음 slot에 보낼 수 있음 if collision: node는 prob.p slot으로 retransmits, 성공할 때까지 Pros: single active node라 transmit 을 full rate로 사용가능 simple Cons collisions, slot 낭비 대기 슬롯 시간 동기화 Random access protocols: CSMA CSMA (carrier sense multiple access): transmit 하기 전 누가 사용하는지 확인 if channel sensed idle: transmit entire frame if channel sensed busy, defer transmission 대화하는데 끼어들지 않기 Random access protocols: CSMA collisions Collision이 발생할 수 있음 propagation delay(전파 지연) Collision 패킷을 전부 보낼 때까지 시간 낭비됨 Random access protocols: CSMA/CD CDMA/CD (collision detection) 짧은 시간에 collisions detected 충돌된 transmission 중단, channel wastage 감소 collsition detection: easy in wired LANs: 신호 강도 측정, transmitted 비교, received signals difficult in wireless LANs: 신호 왜곡이나 수신강도로 판단하기 어려움 (CSMA/CA 사용) 예의 바른사람(끼어들어도 봐줌) 구성 NIC(Network Interface Card)가 datagram을 network layer로부터 받고 crates frame If NIC senses channel idle, frame transmission 시작, If NIC senses channel busy, channel이 idle 될때까지 대기후 tranmits. 만약 NIC가 다른 transmission의 방해 없이 transmit되면, 전송이 성공적으로 마무리됨 만약 NIC가 또다른 transmission detects하면, send를 abort(중단)함 After aborting, NIC enter binary(exponential) backoff: n-th의 collision이 발생하면, NIC는 {0, 1, 2, …, 2^n-1}중에 K를 랜덤하게 선택, NIC waits K*512 bits times, returns to Step 2 Longer backoff interval은 많은 collision이 있는것 Taking turnsTaking turns: polling protocol master node에서 slave nodes에게 순서대로 transmit을 invites해줌 일반적으로 “dumb”한 slave devices에서 사용 concerns(우려사항): polling overhead latency single point of failure (master가 오류가 나면 전부 사용하지 못함) Tacking turns: token passing 토큰 메시지가 한 노드에서 다음 노드로 순서대로 전달됨 concerns(우려사항): polling overhead latency single point of failure (token이 오류가 나면 전부 사용하지 못함) Switched local networks 3개 학과, 2개 서버와 4개의 스위치 라우터 스위치들은 link-layer에서 동작 link-layer frame으로 동작(L2 switch) network-layer address 인지못함 routing algorithm 사용 못함(요즘은 됨) MAC address and ARP 32-bit ip address: Network-layer 에서 사용하는 주소 layer 3에서 forwarding하는데 사용 MAC(or LAN or physical or Ethernet) address: locally하게만 사용, 한 인터페이스마다 고유한 주소 48 bit MAC address, NIC ROM에 고정되있음 e.g. 00:d0:ca:1c:f0:ed (3bytes: 제조업체 식별정보, 3bytes: 시리얼 넘버) 데이터를 보낼 때 보내고자하는 Destination MAC 주소를 사용 Broadcast address (FF:FF:FF:FF:FF:FF) MAC address (more) MAC address는 IEEE에서 관리 비유: MAC address: 주민등록번호 IP address: 우편주소 MAC flat address -&gt; 휴대성 LAN카드만 옮기면 됨 IP hierarchical address not protable IP subnet때문에 휴대성 부족 ARP: address resolution protocol 모든 PC들은 network-layer address(IP주소)와 link-layer address(MAC주소)를 같이 가지고 있음 두 addresses 사이에 translate 필요 ARP table 각 IP node들은 ARP table을 가지고 있음 ARP table 구성: &lt;IP address, MAC address, TTL&gt; TTL(Time to Live): mapping이 유지되는 시간(일반적으로 20min) ARP protocol: same LAN A는 Local에 있는 B에게 datagram을 전송하고 싶어함 A의 ARP table에는 B의 MAC address가 존재하지 않음 A가 ARP query packet을 만들어서 B의 IP address를 포함한 후 broadcast해줌 Destination MAC address = FF-FF-FF-FF-FF-FF All nodes on LAN receive ARP query B가 ARP packet 받음, A에게 자신의 MAC address 회신 A의 MAC address로 unicast A caches IP-to-MAC address를 pair로 ARP table에 저장 ARP is “plug-and-play” Addressing: routing to another LAN A에서 R을 거쳐 B로 datagram send create IP datagram with IP source A, destination Blink-layer frame의 destination address를 R의 MAC address로 전송 frame sent from A to RR에서 frame 수신, datagram removed, passed up to IP R에서 IP source A, destination B로 datagram forwardlink-layer frame의 destination address는 B의 MAC address, source는 R회신도 같은 구조 Ethernet wired Lan technology의 표준: 먼저 널리 사용된 LAN technology 간단하고, 저렴함 성능도 좋음 bus: 90년도까지 사용 모든 노드는 same colision domain (서로 충돌할 수 있음) star: 오늘날 사용 중앙에 스위치 활성화 각각 direct로 사용 Ethernet frame structure Sending adapter는 Ethernet frame에 IP datagram을 캡슐화 Preamble (8bytes) 정해져있는 패턴 시작점을 포착하기 위함, 동기화용 Addresses (6bytes) source, destination MAC address Type (2bytes) higher layer protocol을 나타냄 (주로 IP) Data field (46 to 1,500 bytes) IP datagram 포함 이더넷의 MTU(Maximum transmission unit)이 1,500 bytes로 정해짐 CRC (4bytes) Error detected Ethernet: unreliable, conntectionless Connectionless (연결없음) no handshaking betwween sending and receiving NICs Unreliable (신뢰하지 않는) NIC는 acks랑 nacks를 보내지 않음 initial sender가 higher layer rdt(e.g., TCP)를 사용하는 경우에만 dropped된 frames를 recovered해주고, 그외에는 데이터를 버림 Ethernet’s MAC protocol unslotted CSMA/CD with binary backoff Link-layer Switches Link-layer device: takes an active role switch의 역할: 받은 패킷을 다른쪽 links로 forawrd 해주는 역할 transparent(투명함) host는 switches의 존재를 알아차리기 어려움 forwarding만 해주기 때문 plug-and-play, self-learning Filtering과 forwarding Filtering: Switch function이 하는 역할, frame을 어디로 보내야할지, drop시켜야할지 결정 Forwarding: Filtering에서 보내져야할 패킷이라고 결정되면, Input port에 따라서 어느 output port로 보내야할지 결정 Switch: multiple simultaneous transmissons 각 호스트는 switch와 개별로 연결되있음 동시에 들어와도 collision이 발생하지 않음 Switch: self-learning 스위치는 어떤 인터페이스를 통해 어떤 호스트로 갈 수 있는지 학습 frame을 가져오면, 스위치는 sender의 주소를 “학습”: 들어오는 LAN segment sender/location pair 을 switch table에 기록 frame destination을 모르면, broadcast reply 받으면 기록 Switches vs. Routers 둘 다 store and forward: routers: network-layer devices switches: link-layer devices 둘 다 forwarding table 존재: routers: IP주소 기반 switches: MAC 주소 기반 하지만 최근엔 L3 switches 사용 VLAN (Virtual Local Area Network) single broadcast domain: all layer-2 broadcast traffic security/privacy, efficiency issues Virtual Local Area Network: broadcast domain을 나누어주는 역할 1개의 switch를 가상으로 2개의 switch가 있다고 생각할 수 있도록 만들어줌 라우터를 이용하여 VLAN끼리 통신 trunk port: 여러개의 물리적인 스위치에 정의된 VLAN간에 프레임 전달 Summary: A day in the life of a web request DHCP로 IP주소를 받아옴 ARP로 DNS서버 접근, 주소를 받아옴 TCP connection(3-way handshaking) HTTP request를 보냄, reply 받음 웹페이지 열림","link":"/2021/12/08/dataNetwork-link/"},{"title":"[강의정리] 데이터통신과네트워크 침입탐지시스템","text":"네트워크 트래픽 분석과 악성코드 악성코드를 분석하는데 네트워크 트래픽 분석이 왜 필요할까? 악성코드는 네트워크 기술이 발달함에 따라 배포 및 명령 전달이 용이해짐 86년도부터 급격히 증가한 배경은 인터넷 기술의 발전 출현개수와 새로운 종의 출현은 인터넷 보급속도와 유사하게 증가 인터넷을 통한 악성코드 감염 경로 인터넷 브라우저 불법 크랙 프로그램 피싱/파밍 외부 문서의 매크로 파악 네트워크 트래픽 분석을 통해 악성코드의 정확한 행위를 파악 가능 대부분 악성코드는 네트워크 사용 DDoS 공격을 위한 좀비 PC를 모으거나, 특정사용자 파일 감시, 악의적인 파일 암호화등의 악성행위는 네트워크가 필요한 경우가 많음 네트워크 트래픽을 통한 악성코드 통신 차단 기능 방화벽을 통한 의심 ip, 포트 차단 Intrusion Detection System(IDS)를 통한 네트워크 공격 탐지 및 Intrusion Prevention System (IPS)를 통한 네트워크 트래픽 차단 보안 관점에서 바라본 OSI 7계층 L2: MAC L3: IP L4: 프로토콜(TCP/UDP) L7: 페이로드 L2 계층 데이터 링크 계층으로 MAC과 가장 관련이 깊음 Source MAC주소와 Destination MAC 주소를 보고 Switch에서 차단 가능 L2 방화벽 L2와 가장 관계가 깊은 보안 시스템은 방화벽 일반적으로 방화벽의 경우 최소 2개 이상의 NIC 필요 장점 L2 방화벽을 설치 할 때 일반적으로 네트워크 디자인을 바꾸지 않아도 됨 단점 동일한 네트워크 안에서만 가능, 다양한 네트워크 환경에는 적용 불가능 L3 계층 네트워크 계층으로 IP 주소와 연관 있음 하나의 네트워크 장비(e.g., 방화벽)를 통해 여러개의 네트워크 망을 구성 NAT와 VLAN기술 필요 L3 방화벽 장점 L2 방화벽에선 하지 못했던 좀 더 다양한 접근 제어 가능 NAT과 VLAN 활용 단점 L3 방화벽을 설치할 때 일반적으로 네트워크 디자인을 바꿔야 할 수도 있음 L4 계층 전송계층 패킷을 포트수준까지 확인 L7 계층 L5는 세션계층, L6는 표현계층, L7은 응용계층 요즘에는 L5,6,7을 통틀어 L7이라 부르기도 함 L7 방화벽에서는 패킷 페이로드를 활용하여 운용 가능 방화벽 하드웨어 기반 방화벽: 여러대의 PC와 서버를 커버함 소프트웨어 기반 방화벽: 설치된 host PC만 보호 방화벽: 1세대 방화벽 패킷 필터링 기반의 1세대 방화벽 src IP dst IP src Port dst Port Control any 1.1.1.1 any 80 permit 80포트 listen 80포트에 대한 접근 허용(HTTP 포트) 무수히 많은 룰을 셋팅해야함 80번 포트를 열때 나가는 포트에 대해 많은 포트를 열어줘야함 룰관리 이슈 포트 개방에 따른 이슈 방화벽: 2세대 방화벽 Stateful Inspection: TCP 접속 시 방화벽에서 패킷의 payload를 보면서 3way handshake의 state 추적, rule을 자동으로 추가 장점: Response 패킷에 대한 룰을 불필요하게 작성할필요 없음 동작하는 동안 checksum도 계산, 잘못된패킷은 폐기 가능 방화벽: 3세대 방화벽 L7 방화멱 또는 애플리케이션 방화벽 실제 패킷 내용 검사, 단순한 포트/IP 조사뿐만 아니라 어떤 애플리케이션과 통신하고있는지 파악 2세대 방화벽: 80/443 허용이나 차단 가능 3세대 방화벽: 페이스북 차단, 인스타 허용같은 룰 가능 L2, L3, L4 모두 커버 가능하지만 성능 이슈로 L7에 집중하기도 함 범용적인 서비스보단 오피스용 방화벽 구성 Intranet: 직원 내부망 서비스대역(DMZ): 네트워크 중립지역, 외부에 서비스를 제공할때 내부 네트워크와 분리시킨 공간 A구간: 외부에서 서버 접속 (서비스 대역으로 오는 접속) 외부로 공개된 웹서버가 존재하면, HTTP(80), HTTPS(443) 포트 허용 그밖의 모든 포트 차단 (E.g., RDP(3389), SSH(22)) B구간: 내부망에서 서버로 접속 내부망에 존재하는 엔지니어들을 위해 다양한 제어 포트를 열어둠 E.g., HTTP(80), HTTPS(443), SSH(22), RDP(3389) 등 C구간: 서버에서 외부망 접속 서버 패치를 위해 Linux Repository 접근 허용 일반 사이트는 접속 불허용! D구간: 내부망에서 외부망으로 접속 서버 패치를 위해 Linux Repository 접근 허용 파일 유출 방지를 위해 구글드라이브, 네이버 드라이브 불허용 악성코드 감염 방지를 위해 악성 사이트 접근 불허용 High Availability (HA) High Availability: 2대의 방화벽을 통해, 1개의 방화벽에 장애가 생길경우를 대비 한대는 온라인 상태, 한대는 대기/레디 상태 (Active-Standby) 두개가 항상 온라인 상태 (Active-Active) 바이패스 스위치 방화벽에 장애가 생겼을 경우, 우회경로 만들어줌 보안보다 서비스가 중요하다고 판단될 경우 Full Mesh 네트워크 장비를 2대 이상 준비한 후, 모두 연결 방화벽 룰 관리 오래된 룰은 정기적으로 확인 후, 필요없는 경우 해당룰을 지워줌 룰이 겹치지 않도록 튜닝하는것도 필요 침입탐지시스템탐지 방법 Signature 기반 공격 탐지 악성 공격의 일정한 패턴(Signature)을 탐지 룰에 추가함으로 공격을 탐지 알려지지 않은 공격을 탐지하지 못함 한계를 극복하기 위해 Anomaly 기반 공격 탐지가 설계됨 Anomaly 기반 공격 탐지 비정상적인 트래픽이 발생하면 공격으로 감지 E.g., 평소 IP주소당 최대 1Mbps, 어느날 20Mbps? 공격이다! 오탐존재 Signature 기반 공격 탐지 IDS는 다음과 같은 탐지 룰을 기반으로 작동12Alert tcp any any -&gt; any any (msg: &quot;LoCAL-RULE Test for TestMyIDS&quot;;content: &quot;testmyids.com&quot;; classtype:misc-activity; sid:1000001;rev:1;) 알람 조건 Source ip 주소와 Destination ip 주소 any any Source port number와 Destination port number any any Payload에 “testmyids.com” 문구 포함 Anomaly 기반 공격 탐지 IPS 트래픽을 학습하는 방법: 다양한 Machine learning 기반 방법 IDS 종류 NIDS (Network-based IDS) 네트워크 인프라를 기준으로 동작하는 IDS HIDS (Host-based IDS) Host를 관리하는 상황헤서 동작하는 IDS 장점 NIDS: 네트워크 전체를 한군데서 분석 가능 HIDS: Host별 상세 분석 가능, 사용자단위 분석도 가능 단점 NIDS: IDS를 경우한 공격만 확인 가능, 암호화된 트래픽도 못봄 HIDS: 개별로 관리해야함 NIDS 탐지 위주 정책, 인라인으로 들어가지 않음(따로 삐져나와있음) 장애를 예방하기위한 이중화 구성이 필수가아님 NIDS에 장애가 발생해도 네트워크 로그의 저장이 필요하면 이중화구성 해야함(Backup 장비 이용) NIDS에 필요한것: 전체 네트워크 패킷 네트워크 패킷을 복사해서 IDS로 전송 Cisco에서는 트래픽복사하는 행위를 SPAN(Switch Port Analyzer) 대부분의 스위치가 SPAN or 포트미러링 제공 HIDS의 경우 호스트 네트워크 패킷, 시스템 로그 필요 포트 미러링 스위치 환경에서 포트 미러링을 통해 스니핑(패킷 엿듣기) 제공 스위치 환경에서 패킷 분석을 위해 스위치포트에 스니퍼 연결 스위치가 포트미러링을 지원, 스니퍼를 연결하기 위한 포트가 있어야함 포트 미러링을 할 때 미러링하는 포트의 처리율을 알아야 함. HIDS HIDS 필요한것: 호스트 네트워크 데이터 + 시스템 로그 데이터 utmp(x) 로그 utmp 데몬: utmp(x) 파일에 로그 남기는 프로그램 utmp 데몬은 리눅스의 가장 기본 로깅을 제공하는 데몬 현재 시스템에 로그인한 사용자의 상태 출력 utmp 데몬에 저장된 로그를 출력하는 명령: w, who, users, whodo, finger 등 w: 현재 시스템에 로그인된 계정, 셸종류, 로그인시간, 실행중인 프로세스 종류 who: 접속한 시스템의 IP 확인 wtmp(x) 로그 wtmp 데몬: wtmp(x) 파일에 로그 남김, /usr/include/utmp.h 파일 구조체 사용 utmp데몬과 비슷한 역할, 사용자들의 로그인,로그아웃,재부팅 정보 수록 last명령 이용 su(switch user) 로그 권한 변경에 대한 로그 cat /var/adm/sulog pacct 로그 시스템에 로그인한 모든 사용자가 수행한 프로그램 정보 저장 acctcom 명령 이용 root 계정으로 vi에디터 실행한 기록: acctcom -u root -n vi lastcomm명령: 실행된 날짜 출력 리눅스 로그 분석과 설정 syslog 시스템의 로그 정보를 대부분 수집해서 로깅 로그종류와 수준은 /etc/syslog.conf 파일 authlog/loginlog 실패한 로그인 시도에 대한 로깅 (loginlog 파일에 저장) 설정: etc/default/login, 재부팅후 적용 IDS vs. IPS Intrusion Detection System Intrusion Prevention System IDS는 공격에 대한 블록기능 X, 탐지만 하는경우가 많음 IPS IDS 시스템 타입 액티브(모니터링, 차단까지) 패시브(모니터링, 경고) 매커니즘 Anomaly based detection\\nSigniture detection Anomaly based detection\\nSigniture detection 위치 Inline형태로 설치 Out of band 대응방법 경고를 주거나 패킷을 Drop 알람 보냄 퍼포먼스 영향 패킷속도에 저하가 생길 수 있음 복사해서 분석하기 때문에 퍼포먼스적 영향 X benefits 자동화되고, 방지도 되기 때문에 회사에서 선호 IPS가 차단할 합법적인 traffic을 차단하지 않음","link":"/2021/12/09/intrust-detection/"},{"title":"[강의정리] 데이터통신과네트워크 네트워크와 암호","text":"암호기술암호학적 해쉬 함수 Cryptographic hash functions one-way function: 한방향으로만 입출력(출력값을가지고 입력값을 구하기 어려움) 해쉬 함수 특징 1차 역상 저항성(Preimage resistance): output을 가지고 input을 유추하기 어려움 Avalanche effect 입력값이 1비트 값만 변하더라도 결과값은 전혀 다른값이 됨 암호학적 해쉬 함수 종류 MD5, SHA1, SHA256… 사용 예: 파일 이미지 확인, 패스워드 생성기 대칭키 암호 평문 (Planetext): 암호화 되기 전 메시지 암호문 (Ciphertext): 암호화된 메시지 구성요소 암호알고리즘: E() 암호화 키: K 암호화(Encryption): EK(P) = C 복호화(Decryption): DK(C) = P 대칭키 암호 (Symmetric key encryption) 스트림 암호 (Stream Cipher): RC4, OTP, … 블록 암호 (Block cipher): DES, AES, SEED, … 블록 암호 (Block Cipher) 실생활에서 주로 사용되는 대칭키 암호 시스템 평문을 고정된 길이의 블록으로 나눈 후, 암호화 과정 진행 암호문 길이 = 평문 길이 대칭키 암호 (DES) 1977년에 표준으로 제정 2007년에 6.4일만에 해독됨 대칭키 암호 (AES) 1997년 NIST가 차세대 암호 표쥰(AES: Advanced encryption standard) 공모 벨기에 암호학자들이 제안한 블록 암호 시스템 선정 메시지 인증 코드 (MAC) MAC(Message authentication code) MAC 구성요소 MAC 알고리즘: MAC() MAC Key: K MAC을 만드는 방법 블록암호 기반 MAC 알고리즘 암호학적 해쉬 기반 MAC 알고리즘 (일반적) 공개키 암호 시스템 공개키 암호(Public key system or Asymmetric key system) 공개키 암호는 한쌍의 키를 가지고 있음 공개키: 외부로 공개하는 키 값 개인키: 자신만 가지고 있는 키 값 수학적 난제를 통해 키를 생성 전자서명 시스템에 자주 사용 네트워크와 암호Backgrounds Link encryption 암호화가 모든 링크에서 독립적으로 수행 모든 링크간의 사전에 공유된 암호화 키 필요 End-to-End encryption 암호화가 시작점과 도착점에서 수행 End-to-End 암호화 헤더부분(e.g., IP address)은 암호화 되지 않음 헤더정보를 통해 인터넷 패킷들을 라우팅 헤더정보가 암호화되지 않으므로 traffic 흐름 노출 End-to-End에서는 A와 B가 통신하고 있다는 사실 노출 그래서 End-to-End와 Link 암호화 동시에 사용되기도 함 End-to-End 암호화: 데이터 보호 Link 암호화: traffic 흐름 숨김 둘다 대부분 대칭키 암호 사용 (e.g., AES) 비대칭키 암호(공개키 암호)는 주로 암호화 키 교환(혹은 인증)에 사용 SSL/TLS 프로토콜 구조 SSL/TLS 프로토콜은 클라이언트와 서버의 통신에 메시지 인증, 기밀성, 가용성 제공 암호화 되지 않은 패킷 (e.g., HTTP)는 SSL패킷으로 인코딩 되면서 암호화 진행 (HTTP SSL) 구조 Handshake protocol 암호화/인증 통신을 위해 사용할 알고리즘의 종류 그리고 암호화/인증 키에 대해 협의 ChangeCipherSpec protocol Handshake 프로토콜을 통해 교환된 정보들을(e.g., 암호 알고리즘 종류, 암호화 키) 확인 Alert protocol TLS 괒어 중에 발생하는 에러 혹은 비정상적인 상황을 리포트 Record portocol TLS에서 전송되는 상위 레이어의 메시지 처리 IPsec IPSec(Internet Protocol Security): SSL과 달리 네트워크 계층에서 보안을 제공하기 위해 IETF(Internet Engineering Task Force)에 의해 표준화된 프로토콜 왜사용? 어플리케이션 레이어에서 보호 안될수도 UDP 사용할수도 Transport mode vs. tunnel mode전송모드 (Transport 모드) IPSec의 기본 모드, end-to-end 보안 제공 IPSec에서 전송모드가 사용되면 IP데이터영역만 보안 처리함으로써 IP데이터 영역을 보호 IP헤더는 보호X 터널모드 (Tunnel 모드) IP패킷 전체를 보호 헤더영역도 보호함 트래픽 흐름 보호 가능 TLS vs. IPSec SSL/TLS transport layer에서 제공 일반 보안통신에 주로 사용 IPSec network layer에서 제공 특수 보안통신(e.g., VPN)에서 주로 샤용 VPN(Virtual Private Network)Tor (The Onion Router)","link":"/2021/12/09/dataNetwork-password/"}],"tags":[{"name":"summary","slug":"summary","link":"/tags/summary/"},{"name":"Div.3","slug":"Div-3","link":"/tags/Div-3/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Problem Solve","slug":"Problem-Solve","link":"/tags/Problem-Solve/"},{"name":"Div.2","slug":"Div-2","link":"/tags/Div-2/"},{"name":"Computer Network","slug":"Computer-Network","link":"/tags/Computer-Network/"},{"name":"Computer Math","slug":"Computer-Math","link":"/tags/Computer-Math/"},{"name":"Information Science","slug":"Information-Science","link":"/tags/Information-Science/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Codeforces","slug":"Algorithm/Codeforces","link":"/categories/Algorithm/Codeforces/"},{"name":"Lecture Summary","slug":"Lecture-Summary","link":"/categories/Lecture-Summary/"},{"name":"Problems","slug":"Algorithm/Codeforces/Problems","link":"/categories/Algorithm/Codeforces/Problems/"},{"name":"Computer Data Network","slug":"Lecture-Summary/Computer-Data-Network","link":"/categories/Lecture-Summary/Computer-Data-Network/"},{"name":"Information Science","slug":"Lecture-Summary/Information-Science","link":"/categories/Lecture-Summary/Information-Science/"},{"name":"Advanced Computer Math","slug":"Lecture-Summary/Advanced-Computer-Math","link":"/categories/Lecture-Summary/Advanced-Computer-Math/"},{"name":"Algorithm","slug":"Lecture-Summary/Algorithm","link":"/categories/Lecture-Summary/Algorithm/"}]}