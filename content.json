{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Codeforces Round #739 (Div. 3) 리뷰","text":"알고리즘 공부를 열심히 하겠다고 마음먹은뒤 결국 Div. 2 하나를 놓치고 지나갔다.결국 바로 다음에 있는 Div. 3부터 치르게 되었는데, 오랜만이라 그런가 생각보다 쉽지 않았다.앞으로 알고리즘 공부한것들의 리뷰를 해볼생각이다. 실력이 조금이라도 늘겠지… Result # A B C D E F1 F2 Attr 1 3 1 0 - - - Attr* - - - 1 - - - Time 20 55 15 Over - - - Solve O O O Late - - - Adjustment Rating Ranking Tear 1023 (+49) 10341 (+3079) Newbie","link":"/2021/08/19/codeforces-739/"},{"title":"Codeforces Round #739 (Div. 3) Problem. A","text":"https://codeforces.com/contest/1560/problem/ACodeforces Round #739 (Div. 3) A. Dislike of Threes TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 implementation Attr SubNo SolveTime Time Memory Accept? 1 126297598 20min 31 ms 3660KB Accepted 문제 요약Polycarp은 3을 싫어한다. 3으로 끝나는 문자와 3으로 나누어 떨어지는 문자를 제외하고 숫자를 세어서 n번째 숫자를 구해라 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= k &lt;= 1000) Output각 Testcase 마다1개의 정수 x : Polycarp이 싫어하지 않는 k-th 숫자 문제 풀이정말 간단하게 풀 수 있다. 단순한 1차원 반복문을 사용하여 num이 3으로 나누어떨어지거나 3으로 끝나면(10으로 나누었을때 나머지가 3이면) 한번 더 더해서 카운트를 건너뛰어주었다. 최종 코드123456789101112131415161718192021#include &lt;iostream&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int k; cin &gt;&gt; k; int num = 0; for(int i = 1; i &lt;= k; i++) { num++; while(num % 3 == 0 || num % 10 == 3) num++; } cout &lt;&lt; num &lt;&lt; endl; } return 0;} 느낀점800점대 문제면서 Div. 3 A번 문제라 정말 쉬웠다. 간단한 루프문으로 해결될줄은 몰랐지만 생각보다 빠르게 끝냈다.","link":"/2021/08/21/codeforces-739-A/"},{"title":"Codeforces Round #739 (Div. 3) Problem. B","text":"https://codeforces.com/contest/1560/problem/BCodeforces Round #739 (Div. 3) B. Who’s Opposite? TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 math Attr SubNo SolveTime Time Memory Accept? 1 126327661 +40min 1000 ms 3700KB Time limit 2 126332184 +8min (48m) 77 ms 3600KB Wrong answer 3 126336434 +8min (56m) 93 ms 3700KB Accepted 문제 요약원형의 식탁에서 회의를 하는데 인원은 모르고(짝수이다) 모든 사람은 서로 마주보는 상대가 있다.각자의 번호는 1부터 시작해서 시계방향으로 숫자를 매긴다.a 와 b가 마주보고 있을 때, c와 마주보고 있는 사람의 번호를 구하여라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 104)각 Testcase 마다t-th line : space로 구분된 3개의 정수 (1 &lt;= a, b, c &lt;= 108) Output각 Testcase 마다1개의 정수 d : c와 마주보고있는 숫자답이 여러개일시 아무거나 출력, 답이 없으면 -1출력 문제 풀이이문제 또한 어려운 문제는 아니였다. 규칙만 잘 찾으면 되는 문제였지만, 예상외로 해맸었다. Attr 1 (Time Limit exceeded on test 2)첫시도부터 굉장히 복잡하게 생각을 했는데 일단 무조건 규칙이 있을것이라고 예상을 하였다. 그래서 열심히 규칙을 찾아본 결과..서로 마주보는 a와 b를 기준으로 a-n은 b-n을 마주보고 있다는 사실을 알게 되었다.또한 계속 빼가다가 어느 한 수가 0에 도달하게 되면, 큰수 + (큰수 - n - 작은수)가 원탁에 앉아있는 총 인원 수가 나왔다. 복잡하다또는 큰수-n과 작은수의 값이 같아지면, 큰수 + (작은수 - n) 의 값이 총 인원수가 되었다. 결국 for문으로 돌려서 위 두 케이스중 하나의 케이스가 나오게 되면 Loop를 빠져나가고 남은 값들을 계산하여 값을 도출해 냈다. 물론 결과는 시간 초과최대 시간복잡도가 104X108 = 1012(약 1조…)가 나와버린다… 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); int i, meet = small - 1; int result = -1; for (i = big-1; i &gt; small &amp;&amp; meet &gt; 0; i--, meet--) { if (result == -1) { if(i == c) result = meet; else if(meet == c) result = i; } } //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;, m = &quot; &lt;&lt; meet &lt;&lt; endl; if(result == -1 &amp;&amp; i &gt; small &amp;&amp; meet == 0) { if(c &gt; small &amp;&amp; c &lt;= i) result = big + (c-small); else if(c &gt; big &amp;&amp; c &lt;= (big + (i-small))) result = small + (c-big); } cout &lt;&lt; result &lt;&lt; endl; } return 0;} Attr 2 (Wrong answer on test 2)시간초과로 한대 맞고난 뒤 for문으로 해결할 수 없는 문제라는 사실을 문제를 본지 40분만에 알아차렸다. 결국 다른 규칙을 찾다가 한가지 핵심적인 규칙을 깨닳을 수 있었다. 서로 마주보고있는 두 수의 간격은 무조건 전체 인원수의 절반이 된다.이 규칙을 찾은 후 이 규칙을 가지고 코드를 짰다. 기본적으로 두 수의 간격을 구하고, 그 간격을 기준으로 c값이 작으면 전체 인원수의 절반을 더해주고, c값이 크면 전체 인원수의 절반을 빼주는 형식으로 정답을 구했다. 또한 몇가지의 예외사항을 넣어두었다. 앞에서 했던 for문 뻘짓을 왜했는지 이해가 되지 않았지만 8분만에 코드를 짜고 제출을 하였다.그러나 결과는 오답공식에는 문제가 없었다. 다른 예외사항이 있는듯했다. 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c, result = -1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); int dis = big - small; if(c &gt; dis) result = c-dis; else if (c &lt;= dis) result = c + dis; if(result &gt; dis*2 || big &gt; dis*2) result = -1; cout &lt;&lt; result &lt;&lt; endl; } return 0;} Attr 3 (Accepted!)결국 또하나의 예외를 찾아내고 나서야 문제를 해결할 수 있었다. “c가 전체 인원수보다 크면: a와 b가 마주보고 있는 원탁에는 c는 존재할 수 없다.”결론적으로 이 예외조건을 추가하니 정상적으로 코드가 Accept 되었다. 최종 해설서로 마주보고있는 두 수의 간격은 무조건 전체 인원수의 절반이 된다. a와 b를 사용하여 전체 인원수의 절반을 구하고, 그 수를 기준으로 하여 c에 따라서 결과값을 구해주면 된다.규칙만 잘찾으면 어렵지않게 풀 수 있는 문제였다. 괜히 반복문으로 접근해서 시간만 날렸다 ?c가 전체 인원수의 절반보다 작거나 같으면: 정답 : c + 전체 인원수의 절반; ?아니면 c가 전체 인원수의 절반보다 크면: 정답 : c - 전체 인원수의 절반; 만약: 정답이 전체 인원수보다 크면: 정답 : -1; 제대로된 원탁이 아니다. 또는: c가 전체 인원수보다 크면: 정답 : -1; a와 b가 마주보고 있는 원탁에는 c는 존재할 수 없다. 또는: a와 b중에 큰 수가 전체 인원수보다 크면: 정답 : -1; a와 b중에 큰 수는 제대로된 원탁에 존재할 수 없다. 최종 코드12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c, result = -1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); //총 인원수의 절반 int dis = big - small; if(c &gt; dis) result = c-dis; else if (c &lt;= dis) result = c + dis; //답이 나오지 않는 경우 if(result &gt; dis*2 || big &gt; dis*2 || c &gt; dis*2) result = -1; cout &lt;&lt; result &lt;&lt; endl; } return 0;} 느낀점원형탁자 -&gt; 숫자 -&gt; 순서대로 -&gt; 반복문!! 일것이라고 안일하개 생각한게 문제가 되었다.결국 초반에 반복문으로 계속 고민을 하다가 시간만 날려버리게 되었다.문제를 해결하는 방법에 편견을 가지지 말고 다양한 방법을 생각해 봐야할 것 같다.","link":"/2021/08/23/codeforces-739-B/"},{"title":"Codeforces Round #739 (Div. 3) Problem. C","text":"https://codeforces.com/contest/1560/problem/CCodeforces Round #739 (Div. 3) C. Infinity Table TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 implementation math Attr SubNo SolveTime Time Memory Accept? 1 126343911 +14min (70m) 30 ms 3600KB Accepted 문제 요약2차원배열 가장 왼쪽 위부터 시작하는 table이 있다. 이table은 다음과같은 패턴으로 순서대로 생성이 된다.위와같은 패턴으로 table이 무한정 생성될 때 k가 존재하는 행과 열을 구하여라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= k &lt;= 109) Output각 Testcase 마다2개의 정수 (r, c &gt;= 1) space로 구분 : k가 위치하고있는 열과 행 문제 풀이또 800점 문제이다. 또한 패턴만 구하면 간단하게 해결할 수 있었다. 0번째 열을 확인해보면 각각 n번째 행의 원소들이 n의 제곱인것을 확인할 수 있다.다르게 말하면 0번째 행의 0보다 큰 n번째 열의 원소는 n-1의 제곱 + 1이라는 사실도 성립된다.또한 변화하는 행과 열의 종류가 변경되는 시점은 n-1의 제곱 + (n-1)이기 때문에 k의 위치는 쉽게 구할 수 있었다. 최종 해설먼저 정수형 sq를 선언하여 k의 제곱근(소수점부분은 제외)을 구하였다. 만약 소수점을 제외한 sq의 제곱이 k와 같다면, k의 위치는 0열 sq행으로 고정되기 때문에 예외를 두어 처리를 해 주었다. 다음으로 알아야 하는것은 k가 위치하고 있는 곳이 열이 변경되는 구간인지, 행이 변경되는 구간인지 알 필요가 있다.먼저 행과 열이 바뀌는 구간은 sq의 제곱 + sq로 구할 수 있다. (행과 열이 만나는 시점) 따라서 해당 값보다 크게 되면, 가로로 배치되는 시점이므로 행의 위치는 sq+1로 고정이며 열의 위치는 sq+1의 제곱에서 k값을 뺀 값이 k가 위치하는 열의 번호가 된다. 또는 행과 열이 만나는 시점보다 k의 값이 작게 되면, 세로로 배치되는 시점이므로 열의 위치는 sq+1로 고정이며 행의 위치는 k에서 sq의 제곱을 뺀 값이 된다. 최종 코드12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;math.h&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int k; cin &gt;&gt; k; int sq = (int)sqrt(k); if(sq*sq == k) { cout &lt;&lt; sq &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt; endl; continue; } if(k &gt; sq*sq+sq) cout &lt;&lt; sq+1 &lt;&lt; &quot; &quot; &lt;&lt; sq-(k-(sq*sq)-sq)+2 &lt;&lt; endl; else cout &lt;&lt; k-(sq*sq) &lt;&lt; &quot; &quot; &lt;&lt; sq+1 &lt;&lt; endl; } return 0;} 느낀점어렵지 않았다. 간단한 공식을 알아내면 쉽게 풀 수 있는 문제였다.앞에서 뻘짓한게 아까웠다..","link":"/2021/08/25/codeforces-739-C/"},{"title":"Codeforces Round #739 (Div. 3) Problem. D (After contest)","text":"https://codeforces.com/contest/1560/problem/DCodeforces Round #739 (Div. 3) D. Make a Power of Two TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 1300 greedy math strings Attr SubNo SolveTime Time Memory Accept? -1 126372797 TIME OVER 233 ms 3700KB Accepted(Late) 문제 요약2의 제곱으로 만들어라. 정수 n이 주어지고, 다음과 같은 행동을 할 수 있다. 임의의 숫자 하나를 지울 수 있다 (만약 숫자가 하나밖에 남지 않았으면 “empty”가 된다) 오른쪽에 숫자 하나를 놓을 수 있다. 가장 왼쪽에 0이 있을 때, 0은 지워지지 않는다.예시) 301에서 3을 빼면, 1이 아닌 01이 된다 최소한의 행동만 하여 n을 2의 제곱으로 만들어라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 104)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= n &lt;= 109) Output각 Testcase 마다1개의 정수 m : 2의 제곱으로 만드는 최소 비용 문제 풀이처음엔 햇갈렸지만, 결국 string을 사용하여 노가다로 풀 수 있는 문제라는 사실을 깨닳았다. 하나의 문자를 구현하기 위해서는 구현할 문자와 비교해가면서 필요없는 숫자는 빼고, 필요한 숫자만 마지막에 더해주면 쉽게 구현을 할 수 있다.(비용은 언제나 최소비용이 든다) 또한 n의 최대 범위가 10의 9승이기 때문에, 아무리 비용이 많이 들어도 9 이상으로는 들지 않을 것이다.10의 9승 이하에서 모든 값을 지우고 1만 추가하면 최대 9의 비용이 나온다 처음엔 long long int의 최대 범위를 10의 19승까지 했지만, 잘못된 선택이였다. long long int의 범위를 잘못 알고 있었었다. 이부분에서 시간을 많이 잡아먹었다결국 long long int의 범위 문제였고, 범위를 10의 18승으로 줄여 문제를 해결했다. 최종 해설먼저 간단한 예외(n이 이미 2의 제곱일때)는 미리 검사하고 걸러냈다. 만약 그렇지 않으면, n을 string으로 바꿔서 시작한다. 그 뒤로 2의 제곱을 계속해서 비교해 가면서 최소비용을 계산을 한다.만약 비용이 1이 나오면, 1보다 작은 비용은 나오지 않기 때문에 검사를 종료하였다. 검사는 n의 digit들을 하나씩 돌아가면서 구현할 숫자와 비교를 한다.n과 다른 숫자가 있으면 해당 digit를 제거하고, n의 탐색이 먼저 끝나면 남은 digit들을 추가해주면 구현이 완료된다. n의 최대값은 109이므로 가장 큰 최소 비용은 9가 된다.10의 9승 이하에서 모든 값을 지우고 1만 추가하면 최대 9의 비용이 나온다그러므로 +-를 계산하여 구현해볼 최대의 2의 제곱수는 1018 까지 확인을 해 주었다. 최종 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;string&gt; using namespace std; bool CheckPow(int a) { while(a &gt; 1) { if(a % 2) return false; a/=2; } return true;} long long int Power(long long int a, long long int b) { long long int result = a; for(long long int i = 1; i &lt; b; i++) result = result * a; return result;} int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int n; cin &gt;&gt; n; if(CheckPow(n)) { cout &lt;&lt; 0 &lt;&lt; endl; continue; } string num = to_string(n); long long int now = 1; int result = 15; int weight = 9; //cout &lt;&lt; (long long int)powl(10, 20) &lt;&lt; endl; //cout &lt;&lt; Power(10, 18) &lt;&lt; endl; while (result &gt; 1 &amp;&amp; now &lt; Power(10, 18)) { string nstr = to_string(now); int i = 0, j = 0; int trash = 0; for(i = 0; i &lt; nstr.length(); i++) { for(j; j &lt; num.length(); j++) { if(nstr[i] == num[j]) break; trash++; } if(j==num.length()) { trash += nstr.length() - i; break; } else j++; } result = min(result, trash + (int)(num.length()-j)); now *= 2; } cout &lt;&lt; result &lt;&lt; endl; } return 0;} 느낀점처음 봤을 때 막막했지만, 오랜시간 고민해본 결과 해법을 알아내고 시간은 얼마 남지 않았었다.결국 오류를 잡지 못하고 대회가 종료되고 말았다. 결국 int의 범위 때문에 큰 오류가 났었는데, 다음부턴 최대값을 정하고 작업을 하는게 안전할 것 같다.","link":"/2021/08/25/codeforces-739-D/"},{"title":"Codeforces Round #740 (Div. 2) 리뷰","text":"서론Codeforces Round #740 (Div. 2, based on VK Cup 2021 - Final (Engine))VK Cup의 최종 문제를 기준으로 출제된 Contest이다. 사실 뭔지 잘 모르지만, 확실한건 내가 알람을 맞춰두지 않았다는 사실이다. 문제를 풀기 시작한 시점은 1시간이 남았을때였다. 2점밖에 올리지 못했는데 1887등이 올랐다…. 이것이 심해인가보다 Result # A B C D E F1 F2 Attr 2 - - - - - - Attr* - - - - - - - Time 45 - - - - - - Solve O - - - - - - Adjustment Rating Ranking Tear 1025 (+2) 8454 (+1887) Newbie","link":"/2021/08/25/codeforces-740/"},{"title":"Codeforces Round #740 (Div. 2) Problem. A","text":"https://codeforces.com/contest/1561/problem/ACodeforces Round #740 (Div. 2, based on VK Cup 2021 - Final (Engine)) A. Simply Strange Sort TimeLimit MemoryLimit Difficulty Tags 2 S 512 MB 800 brute force implementation sortings Attr SubNo SolveTime Time Memory Accept? 1 126892151 20min 31 ms 3600KB Wrong answer 2 126900288 +25min (45m) 46 ms 3700KB Accepted 문제 요약조금 이상한 정렬.. n개의 원소를 가지고있는 배열 a(n개의 원소를 가진 배열, n: 홀수)이 주어진다.배열 a를 오름차순으로 정렬한다. 알고리즘: f(i)를 수행한다.i는 (1 &lt;= i &lt;= n-1)사이로 수행되고, 각 다음과 같은 알고리즘을 사용한다 : 만약 **ai &gt; ai+1**이면, **ai 와 ai+1의 값을 변경한다. 알고리즘은 반복으로 구성되고, 숫자 1부터 시작한다. i번째 반복일 때, 다음과 같은 알고리즘을 수행한다 만약 i가 홀수이면: f(1), f(3),…,f(n-2);를 호출 만약 i가 짝수이면: f(2), f(4),…,f(n-1);를 호출 배열이 오름차순으로 정렬될 때까지 반복한다. 몇번의 반복을 해야 오름차순으로 정렬되는지 구하는 문제… 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다 1-st line : 1개의 정수 (1 &lt;= n &lt;= 1000, n: 홀수) 2-nd line : n개의 정수 a1, a2…,an (1 &lt;= ai &lt;= n) 모든 테스트케이스의 n의 합이 999를 넘지 않는다. Output각 Testcase 마다최초로 오름차순으로 정렬이 되는 최소 반복 횟수를 출력 이미 정렬이 되어있다면, 0을 출력 문제 풀이그냥 무시정으로 반복해도 해결할 수 있는 문제이다. 알고리즘도 다 알려주고 위에서 시키는대로 코드를 짜기만 하면 되는 문제 Attr 1 (Wrong answer on pretest 2)처음에는 checkSorted라는 변수를 하나 만들어서 반복문 안에서 변경되는 점이 있으면 checkSorted를 꺼주고, checkSorted가 꺼지지 않으면 정렬이 된것으로 보고 반복문을 탈출시켜주는 코드였다. 에러가 떴다. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int result = 0; int n, arr[1001]; cin &gt;&gt; n; arr[0] = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; arr[i]; } while(true) { result ++; int checkSorted = true; for(int i = (result%2==0?2:1); i &lt; n; i+=2) { if(arr[i] &gt; arr[i+1]) { //cout &lt;&lt; &quot;exchange &quot; &lt;&lt; arr[i] &lt;&lt; &quot; and &quot; &lt;&lt; arr[i+1] &lt;&lt; endl; int temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; checkSorted = false; } if(arr[i-1] &gt; arr[i]) checkSorted = false; } if(checkSorted) break; } cout &lt;&lt; result - 1 &lt;&lt; endl; } return 0;} Attr 2 (Accepted!)에러가 날만한 테스트 케이스를 하나씩 넣어봤는데 바로 발견할 수 있었다. 1251 2 3 5 4 위의 케이스를 넣었을때, 확인이 되지않고 0으로 출력이 되었다.바로 해결할 수 있는 문제였는데, 햇갈려서 알고리즘을 다시 짜는 수준까지 가버렸다. 시간이 더 걸리더라도 그냥 배열이 정렬되었는지 미리 확인을 하는 코드를 추가했는데, 시간제한이 넉넉하다보니 문제없이 잘 작동하였었다. 바로 해결하지 못한 이유는 위 케이스의 답이 2가아닌 1이라 생각하고 삽질하고 있었다… 최종 해설위의 해설이랑 똑같이 만들었다. n을 먼저받고, 문제에서 1부터 시작했기 때문에 햇갈리지 않기 위해서 배열의 0은 0으로 채워주고 1부터 입력값을 받아주었다. (1~`n`) 그다음 정렬이 될 때까지 무한반복을 해주는데, 먼저 배열이 정렬되었는지 확인을 해준다. 단순히 for문으로 반복하면서 비교를 해주었다. 정렬이 되지않았으면 result값을 1 더해주고 문제에 나온 알고리즘을 수행해준다. 이렇게 반복하면 어렵지 않게 답을 구할 수 있다. 최종 코드12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int result = 0; int n, arr[1001]; cin &gt;&gt; n; arr[0] = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; arr[i]; } while(true) { //check if array sorted int i = 1; for(i; i &lt; n; i++) if(arr[i] &gt; arr[i+1]) break; if(i == n) break; result ++; for(int i = (result%2==0?2:1); i &lt; n; i+=2) { if(arr[i] &gt; arr[i+1]) { //cout &lt;&lt; &quot;exchange &quot; &lt;&lt; arr[i] &lt;&lt; &quot; and &quot; &lt;&lt; arr[i+1] &lt;&lt; endl; int temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; } } } cout &lt;&lt; result &lt;&lt; endl; } return 0;} 느낀점알람은 미리미리 맞춰놓자.정신좀 차리자.","link":"/2021/08/25/codeforces-740-A/"},{"title":"[강의정리] 윈도우프로그래밍 1주차","text":"윈도우 프로그래밍 정리","link":"/2021/09/01/WindowsPorgramming-W1/"},{"title":"[강의정리] 데이터통신과네트워크 Overview","text":"네트워크의 이해네트워크의 사전적 의미 여러한 통신설비를 통해서 두대 이상의 컴퓨터를 서로 연결하는것 다수의 컴퓨터를 네트워크로 연결했을 때 얻을 수 있는 이점 데이터 공유가 용이함 (NAS) 주변장치 공유 (프린터) 눙률적인 통신 (메일) 근거리통신 (Local Area Network)근거리 통신망 (LAN, Local Area Network) 한 건물이나 학교 내 캠퍼스처럼 비교적 가까운 지역에 한정된 통신망 광역통신 (Wide Area Network)광역 통신망 (WAN) 두 개 이상의 근거리 네트워크가 넓은 지역에 걸쳐 연결되어 있는 것 WAN은 하나의 국가 또는 국가와 국가 간을 연결하는 매우 범위가 넓은 네트워크 우리가 매일 사용하는 인터넷 통신방식클라이언트/서버 시스템 다른 컴퓨터에 데이터 전송 서비스를 제공하는 컴퓨터를 ‘서버’라 하고, 서버에서 보내주는 데이터서비스를 수신하는 컴퓨터를 ‘클라이언트’라고 한다. 유니캐스트 네트워크에서 가장 많이 사용하는 방식 서버와 클라이언트 간의 일대일(1:1) 통신 방식 클라이언트의 IP주소와 MAC주소가 필요 브로드캐스트 로컬 LAN(라우터로 구분된 공간)에 있는 모든 네트워크 단말기에 데이터를 보내는 방식 서버와 클라이언트간에 일대모두(1:모두)로 통신하는 데이터 전송 서비스 브로드캐스트의 MAC주소는 FF-FF-FF-FF-FF-FF로 미리 정해져 있다. 다른 라우터를 찾거나, 라우터끼리 데이터를 교환하거나, 서버가 서비스를 제공하려고 모든 클라이언트에게 알릴 때 등 여러 상황에서 사용 하지만 불특정 다수에게 전송되는 서비스라 수신을 원치않는 클라이언트도 수신하므로 네트워크 성능 저하를 가져올 수 있다. 멀티캐스트 브로드캐스트는 데이터를 무조건 CPU로 전송하기 때문에 컴퓨터 자체의 성능을 떨어뜨림 멀티캐스트는 전송하려는 특정 그룹에게만 한 번에 전송할 수 있기 때문에 유니캐스트처럼 반복해서 보낼 필요가 없고, 브로드캐스트처럼 전송받을 필요가 없는 컴퓨터에 보내지 않아도 됨 프로토콜 (Protocol)프로토콜에 대한 이해 본래의 의미는 외교에서 의례 또는 의정서 톰 마릴이 컴퓨터와 컴퓨터 사이에서 메시지를 전달하는 과정이라 정의 프로토콜의 3가지 요소 구문(Syntax): 데이터의 구조나 포멧을 의미 의미(Semantics): 전송되는 데이터의 각 부분이 무엇을 뜻하는지를 알 수 있게 미리 정해둔 규칙(데이터 자체뿐만 아니라 오류 제어, 동기 제어, 흐름 제어를 포함) 순서(Timing): 어떤 데이터를 보낼 것인지와 얼마나 빠르게 데이터를 보낼 것인지 정의 프로토콜의 기능주소 설정(Addressing) 서로 다른 시스템의 두 개체가 통신을 하는경우 필요 순서 제어(Sequence Control) 프로토콜 데이터 단위를 전송할 때 보내는 순서를 명시하는 기능(연결 지향형 (Connection-Oriented)에서만 사용) 데이터 대열의 단편화 및 재조합(Fragmentation &amp; Reassembly) 대용량 파일을 전송할 때 전송 효율이 높은 작은 단위로 나누어 전송한 뒤 전송 받은 시스템에서 이를 재조합 해야 함 어떻게 쪼갤건지, 재조합 할건지 캡슐화(Encapsulation) 데이터에 제어 정보를 추가 연결 제어(Connection Control) 연결 설정, 데이터 전송, 연결 해제에 대한 통제 수행 흐름 제어(Flow Control) 송신측 개체로부터 오는 데이터의 양이나 속도를 조절하는 기능 송신측과 수신측의 속도 차이 등으로 인한 정보 유실을 방지 오류 제어(Error Control) 두 개체에서 데이터를 교환할 때 오류가 발생할 경우, 이를 제어하는 기법 순서를 검사하거나 특정 시간 안에 받지 못하면 재전송을 요구하는 방식 동기화(Synchronization) 두 개체 간에 데이터를 전송할 때 각 개체는 특정 타이머 값이나 윈도우 크기 등을 통해 동시에 정의된 인자 값을 공유하는 것 다중화(Multiplexing) 통신 선로 하나에서 여러 시스템을 동시에 통신할 수 있는 기법 전송 서비스 우선순위 결정, 서비스 등급과 보안 요구 등을 제어하는 서비스 네트워크 계층 구조네트워크 계층화에 대한 이해 1980년대 초 ISO(International Organization for Standardization)은 여러 업체가 만든 시스템에 대해 상호 연동이 가능한 표준 네트워크 모델을 제정할 필요성을 인식 1984년 OSI(Open System Interconnection) 네트워크 모델을 발표 OSI 7계층 모델 OSI 7계층물리 계층: 1계층 실제 장치를 연결하는데 필요한 전기적, 물리적 세부 사항을 정의 물리 계층의 장치로는 허브나 리피터가 있음 데이터 링크 계층: 2계층 점대점(Point-to-Point) 사이의 신뢰성 있는 전송을 보장하기 위한 계층 CRC 기반의 오류 제어와 흐름 제어가 필요 가장 잘 알려진 예는 이더넷 네트워크 계층: 3계층 여러 노드를 거칠 때마다 경로를 찾아주는 역할 라우팅, 흐름 제어, 단편화(Segmentation/Desegmentation), 오류 제어 등을 수행 대표적인 예는 라우터임, 또한 3계층에서 동작하는 스위치를 흔히 L3 스위치라 함. 전송 계층: 4계층 양 끝단 사용자들이 신뢰성 있는 데이터를 주고받을 수 있게 하여 상위 계층이 데이터 전달의 유효성이나 효율성을 고려하지 않아도 되게 해줌. 전송 계층에서 동작하는 프로토콜 중 TCP는 연결 지향(Connetion-Oriented) 프로토콜임 세션 계층: 5계층 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공 TCP/IP 세션을 만들고 없애는 책임을 짐. 표현 계층: 6계층 시스템에서 사용되는 코드 간의 번역을 담당 표현 계층은 data의 Format(형식)을 정의함 응용 계층: 7계층 사용자나 응용 프로그램 사이에 데이터 교환을 가능하게 하는 계층 HTTP, FTP, 터미널 서비스, 메일 프로그램, 디렉토리 서비스 등을 제공 TCP/IP 4계층 OSI 7계층 vs. TCP/IP 4계층 OSI는 개념적인 모델 (실제 구현에서 반드시 지킨다고 볼 수 없음) TCP/IP 프로토콜은 OSI 모델보다 먼저 개발됨 TCP/IP 프로토콜의 계층은 OSI 모델의 계층과 정확히 일치하지 않음 두 계층을 비교할 때, 세션(Session)과 표현(Presentation) 2개의 계층이 TCP/IP프로토콜 그룹에 없다는 것을 알 수 있음 OSI 7 Layer는 장비 개발과 통신 자체를 어떻게 표준으로 잡을지 사용되는 반면에 실질적인 통신 자체는 주로 TCP/IP 프로토콜을 사용함 최근에는 TCP/IP 모델을 5계층으로 분류하기도 함 네트워크 계층 구조: 물리 계층1계층: 물리 계층(Physical Layer) 두 시스템 간에 데이터를 전송하려고 링크를 활성화하고 관리하는 전기적 · 기계적 · 절차적 · 기능적 특성 등을 정의 OSI 참조 모델 7계층 중 물리 계층은 최하위 계층인 첫 번째 계층으로, 상위 계층에서 전송된 데이터를 물리매체를 통해 다른 시스템에 전기적 신호로 전송 LAN 카드, 케이블, 허브, 라우터 등 물리적인 것과 데이터 전송에 사용하는 전압 등 기본적인 것들이 물리계층에 속함. 송신 측: 데이터 링크 계층에서 0과 1로 구성된 비트열의 데이터(프레임)을 받아 전기적 신호로 변환한 후 전송매체를 통하여 수신측에 보냄 수신 측: 송신측에서 받은 전기 신호를 0과 1로 구성된 비트열로 복원, 수신측의 데이터 링크 계층에 전송 물리 계층 관련 장비리피터(Repeater) 네트워클르 연장하기 위한 장비 불분명해진 신호 세기를 다시 증가시키는 역할 최근 리피터가 모든 네트워크 장비에 공통으로 들어가는 기능이 됨. 허브(Hub) 요즘 쓰이는 스위치의 예전 형태 허브는 스위치와 형태나 사용 방법이 같지만 패킷을 모든 곳에 똑같이 복사해서 보내는 것이 다름(스위치는 목적지에만 데이터를 전송) 네트워크 계층 구조: 데이터 링크 계층2계층: 데이터 링크 계층(Data Link Layer) 물리적 링크를 이용하여 신뢰성 있는 데이터를 전송하는 계층 네트워크를 통해 데이터를 전송할 때 전송로 역할 데이터 링크 계층은 비트를 프레임이라는 논리적 단위로 구성 시스템 간에 오류 없이 데이터를 전송하려고 **네트워크 계층에서 받은 데이터 단위(패킷)를 프레임으로 구성하여 물리 계층으로 전송 데이터 링크 계층의 물리적인 주소: 랜카드나 네트워크 장비의 하드웨어 주소(MAC 주소) 네트워크 카드의 MAC 주소는 윈도우 명령 창에서 ‘ipconfig /all’ 명령을 실행하면 ‘Physical Address’ 에서 확인 가능 리눅스 Machine의 경우 ifconfig 명령어 MAC 주소 총 12개의 16진수로 구성 앞쪽 6개는 네트워크 카드를 만든 회사(OUI: Organizationally Unique Identifier)를 뜻하고, 뒤쪽 6개는 호스트 식별자(Host Identifier)로 각 회사에서 임의로 붙이는 일종의 시리얼 같은 MAC 주소는 존재하지 않음 데이터 링크 계층 프로토콜: 이더넷 제록스의 PARC(Palo Alto Research Center)에서 1970년대에 개발한 데이터 링크 계층의 프로토콜 CSMA/CD (Carrier Sense Multiple Access/Collision Detection) 이더넷의 통신 방식 이더넷 환경에서 통신을 하고 싶을 때, Carrier Sense를 수행함 복수개의 디바이스가 동시에 통신을 시작할 때, Collision이 발생하고 이를 Detection 할 수 있음 Collision Detection이 일어난 후, 랜덤한 시간을 기다리고 다시 데이터를 보냄 데이터 링크 계층 장비브리지(Bridge) 랜(LAN)과 랜(LAN)을 연결하는 초기의 네트워크 장치 데이터 링크 계층에서 통신 선로를 따라서 한 네트워크에서 그 다음 네트워크로 데이터 프레임을 복사하는 역할 스위치 기본적으로 데이터 링크 계층에서 작동하는 스위치를 뜻함 (L2 스위치) 허브의 단점이 Collision Domain의 확대를 해결 L2 스위치는 연결된 시스템이 늘어날수록 패킷 간 충돌 때문에 매우 낮은 속도로 동작하는 더미 허브의 문제점을 해결하는 획기적인 방안 과거에는 브릿지를 통해서 Collision Domain을 나누었지만, 현재는 스위치가 인기가 많음. 스위치의 MAC 주소 테이블 시스템 간의 원활한 통신을 위해 주소 테이블을 생성하고 관리하는 역할 3계층: 네트워크 계층(Network Layer) 랜(LAN)을 벗어난 통신을 하기 위해 네트워크 계층에서 IP 주소를 사용 라우팅 프로토콜을 사용하여 최적의 경로를 선택 네트워크 계층은 데이터를 패킷 단위로 분할하여 전송한 후 재결합함","link":"/2021/09/06/dataNetwork-W1/"},{"title":"[강의정리] 데이터통신과네트워크 OT","text":"수업 개요 TCP/IP 모델을 사용하여 인터넷이 동작하는 원리를 학습 수업 교재 Computer Networking: A Top-Down Approach, 7th Edition (Pearson) James Kurose and Keith Ross 교재에 포함되지 않는 내용은 강의교안을 통해 제공 중간 기말 일정 중간시험 (8주차) 2021년 10월 21일 목요일 오후 7시 (오프라인) 기말시험 (15주차) 2021년 12월 9일 목요일 오후 7시 (오프라인) 성적 처리 중간/기말 시험 60% 기말시험범위: 전범위 과제물 제출 30% 퀴즈 및 과제 포함 출석 및 수업태도 10%","link":"/2021/09/06/dataNetwork-W1-OT/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"summary","slug":"summary","link":"/tags/summary/"},{"name":"Div.3","slug":"Div-3","link":"/tags/Div-3/"},{"name":"Problem Solve","slug":"Problem-Solve","link":"/tags/Problem-Solve/"},{"name":"Div.2","slug":"Div-2","link":"/tags/Div-2/"},{"name":"Computer Network","slug":"Computer-Network","link":"/tags/Computer-Network/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Codeforces","slug":"Algorithm/Codeforces","link":"/categories/Algorithm/Codeforces/"},{"name":"Problems","slug":"Algorithm/Codeforces/Problems","link":"/categories/Algorithm/Codeforces/Problems/"},{"name":"Lecture Summary","slug":"Lecture-Summary","link":"/categories/Lecture-Summary/"},{"name":"Windows Programming","slug":"Lecture-Summary/Windows-Programming","link":"/categories/Lecture-Summary/Windows-Programming/"},{"name":"Computer Data Network","slug":"Lecture-Summary/Computer-Data-Network","link":"/categories/Lecture-Summary/Computer-Data-Network/"}]}