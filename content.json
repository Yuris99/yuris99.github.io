{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Codeforces Round #739 (Div. 3) 리뷰","text":"알고리즘 공부를 열심히 하겠다고 마음먹은뒤 결국 Div. 2 하나를 놓치고 지나갔다.결국 바로 다음에 있는 Div. 3부터 치르게 되었는데, 오랜만이라 그런가 생각보다 쉽지 않았다.앞으로 알고리즘 공부한것들의 리뷰를 해볼생각이다. 실력이 조금이라도 늘겠지… Result # A B C D E F1 F2 Attr 1 3 1 0 - - - Attr* - - - 1 - - - Time 20 55 15 Over - - - Solve O O O Late - - - Adjustment Rating Ranking Tear 1023 (+49) 10341 (+3079) Newbie","link":"/2021/08/19/codeforces-739/"},{"title":"Codeforces Round #739 (Div. 3) Problem. A","text":"https://codeforces.com/contest/1560/problem/ACodeforces Round #739 (Div. 3) A. Dislike of Threes TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 implementation Attr SubNo SolveTime Time Memory Accept? 1 126297598 20min 31 ms 3660KB Accepted 문제 요약Polycarp은 3을 싫어한다. 3으로 끝나는 문자와 3으로 나누어 떨어지는 문자를 제외하고 숫자를 세어서 n번째 숫자를 구해라 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= k &lt;= 1000) Output각 Testcase 마다1개의 정수 x : Polycarp이 싫어하지 않는 k-th 숫자 문제 풀이정말 간단하게 풀 수 있다. 단순한 1차원 반복문을 사용하여 num이 3으로 나누어떨어지거나 3으로 끝나면(10으로 나누었을때 나머지가 3이면) 한번 더 더해서 카운트를 건너뛰어주었다. 최종 코드123456789101112131415161718192021#include &lt;iostream&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int k; cin &gt;&gt; k; int num = 0; for(int i = 1; i &lt;= k; i++) { num++; while(num % 3 == 0 || num % 10 == 3) num++; } cout &lt;&lt; num &lt;&lt; endl; } return 0;} 느낀점800점대 문제면서 Div. 3 A번 문제라 정말 쉬웠다. 간단한 루프문으로 해결될줄은 몰랐지만 생각보다 빠르게 끝냈다.","link":"/2021/08/21/codeforces-739-A/"},{"title":"Codeforces Round #739 (Div. 3) Problem. B","text":"https://codeforces.com/contest/1560/problem/BCodeforces Round #739 (Div. 3) B. Who’s Opposite? TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 math Attr SubNo SolveTime Time Memory Accept? 1 126327661 +40min 1000 ms 3700KB Time limit 2 126332184 +8min (48m) 77 ms 3600KB Wrong answer 3 126336434 +8min (56m) 93 ms 3700KB Accepted 문제 요약원형의 식탁에서 회의를 하는데 인원은 모르고(짝수이다) 모든 사람은 서로 마주보는 상대가 있다.각자의 번호는 1부터 시작해서 시계방향으로 숫자를 매긴다.a 와 b가 마주보고 있을 때, c와 마주보고 있는 사람의 번호를 구하여라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 104)각 Testcase 마다t-th line : space로 구분된 3개의 정수 (1 &lt;= a, b, c &lt;= 108) Output각 Testcase 마다1개의 정수 d : c와 마주보고있는 숫자답이 여러개일시 아무거나 출력, 답이 없으면 -1출력 문제 풀이이문제 또한 어려운 문제는 아니였다. 규칙만 잘 찾으면 되는 문제였지만, 예상외로 해맸었다. Attr 1 (Time Limit exceeded on test 2)첫시도부터 굉장히 복잡하게 생각을 했는데 일단 무조건 규칙이 있을것이라고 예상을 하였다. 그래서 열심히 규칙을 찾아본 결과..서로 마주보는 a와 b를 기준으로 a-n은 b-n을 마주보고 있다는 사실을 알게 되었다.또한 계속 빼가다가 어느 한 수가 0에 도달하게 되면, 큰수 + (큰수 - n - 작은수)가 원탁에 앉아있는 총 인원 수가 나왔다. 복잡하다또는 큰수-n과 작은수의 값이 같아지면, 큰수 + (작은수 - n) 의 값이 총 인원수가 되었다. 결국 for문으로 돌려서 위 두 케이스중 하나의 케이스가 나오게 되면 Loop를 빠져나가고 남은 값들을 계산하여 값을 도출해 냈다. 물론 결과는 시간 초과최대 시간복잡도가 104X108 = 1012(약 1조…)가 나와버린다… 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); int i, meet = small - 1; int result = -1; for (i = big-1; i &gt; small &amp;&amp; meet &gt; 0; i--, meet--) { if (result == -1) { if(i == c) result = meet; else if(meet == c) result = i; } } //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;, m = &quot; &lt;&lt; meet &lt;&lt; endl; if(result == -1 &amp;&amp; i &gt; small &amp;&amp; meet == 0) { if(c &gt; small &amp;&amp; c &lt;= i) result = big + (c-small); else if(c &gt; big &amp;&amp; c &lt;= (big + (i-small))) result = small + (c-big); } cout &lt;&lt; result &lt;&lt; endl; } return 0;} Attr 2 (Wrong answer on test 2)시간초과로 한대 맞고난 뒤 for문으로 해결할 수 없는 문제라는 사실을 문제를 본지 40분만에 알아차렸다. 결국 다른 규칙을 찾다가 한가지 핵심적인 규칙을 깨닳을 수 있었다. 서로 마주보고있는 두 수의 간격은 무조건 전체 인원수의 절반이 된다.이 규칙을 찾은 후 이 규칙을 가지고 코드를 짰다. 기본적으로 두 수의 간격을 구하고, 그 간격을 기준으로 c값이 작으면 전체 인원수의 절반을 더해주고, c값이 크면 전체 인원수의 절반을 빼주는 형식으로 정답을 구했다. 또한 몇가지의 예외사항을 넣어두었다. 앞에서 했던 for문 뻘짓을 왜했는지 이해가 되지 않았지만 8분만에 코드를 짜고 제출을 하였다.그러나 결과는 오답공식에는 문제가 없었다. 다른 예외사항이 있는듯했다. 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c, result = -1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); int dis = big - small; if(c &gt; dis) result = c-dis; else if (c &lt;= dis) result = c + dis; if(result &gt; dis*2 || big &gt; dis*2) result = -1; cout &lt;&lt; result &lt;&lt; endl; } return 0;} Attr 3 (Accepted!)결국 또하나의 예외를 찾아내고 나서야 문제를 해결할 수 있었다. “c가 전체 인원수보다 크면: a와 b가 마주보고 있는 원탁에는 c는 존재할 수 없다.”결론적으로 이 예외조건을 추가하니 정상적으로 코드가 Accept 되었다. 최종 해설서로 마주보고있는 두 수의 간격은 무조건 전체 인원수의 절반이 된다. a와 b를 사용하여 전체 인원수의 절반을 구하고, 그 수를 기준으로 하여 c에 따라서 결과값을 구해주면 된다.규칙만 잘찾으면 어렵지않게 풀 수 있는 문제였다. 괜히 반복문으로 접근해서 시간만 날렸다 ?c가 전체 인원수의 절반보다 작거나 같으면: 정답 : c + 전체 인원수의 절반; ?아니면 c가 전체 인원수의 절반보다 크면: 정답 : c - 전체 인원수의 절반; 만약: 정답이 전체 인원수보다 크면: 정답 : -1; 제대로된 원탁이 아니다. 또는: c가 전체 인원수보다 크면: 정답 : -1; a와 b가 마주보고 있는 원탁에는 c는 존재할 수 없다. 또는: a와 b중에 큰 수가 전체 인원수보다 크면: 정답 : -1; a와 b중에 큰 수는 제대로된 원탁에 존재할 수 없다. 최종 코드12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c, result = -1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); //총 인원수의 절반 int dis = big - small; if(c &gt; dis) result = c-dis; else if (c &lt;= dis) result = c + dis; //답이 나오지 않는 경우 if(result &gt; dis*2 || big &gt; dis*2 || c &gt; dis*2) result = -1; cout &lt;&lt; result &lt;&lt; endl; } return 0;} 느낀점원형탁자 -&gt; 숫자 -&gt; 순서대로 -&gt; 반복문!! 일것이라고 안일하개 생각한게 문제가 되었다.결국 초반에 반복문으로 계속 고민을 하다가 시간만 날려버리게 되었다.문제를 해결하는 방법에 편견을 가지지 말고 다양한 방법을 생각해 봐야할 것 같다.","link":"/2021/08/23/codeforces-739-B/"},{"title":"Codeforces Round #739 (Div. 3) Problem. C","text":"https://codeforces.com/contest/1560/problem/CCodeforces Round #739 (Div. 3) C. Infinity Table TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 implementation math Attr SubNo SolveTime Time Memory Accept? 1 126343911 +14min (70m) 30 ms 3600KB Accepted 문제 요약2차원배열 가장 왼쪽 위부터 시작하는 table이 있다. 이table은 다음과같은 패턴으로 순서대로 생성이 된다.위와같은 패턴으로 table이 무한정 생성될 때 k가 존재하는 행과 열을 구하여라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= k &lt;= 109) Output각 Testcase 마다2개의 정수 (r, c &gt;= 1) space로 구분 : k가 위치하고있는 열과 행 문제 풀이또 800점 문제이다. 또한 패턴만 구하면 간단하게 해결할 수 있었다. 0번째 열을 확인해보면 각각 n번째 행의 원소들이 n의 제곱인것을 확인할 수 있다.다르게 말하면 0번째 행의 0보다 큰 n번째 열의 원소는 n-1의 제곱 + 1이라는 사실도 성립된다.또한 변화하는 행과 열의 종류가 변경되는 시점은 n-1의 제곱 + (n-1)이기 때문에 k의 위치는 쉽게 구할 수 있었다. 최종 해설먼저 정수형 sq를 선언하여 k의 제곱근(소수점부분은 제외)을 구하였다. 만약 소수점을 제외한 sq의 제곱이 k와 같다면, k의 위치는 0열 sq행으로 고정되기 때문에 예외를 두어 처리를 해 주었다. 다음으로 알아야 하는것은 k가 위치하고 있는 곳이 열이 변경되는 구간인지, 행이 변경되는 구간인지 알 필요가 있다.먼저 행과 열이 바뀌는 구간은 sq의 제곱 + sq로 구할 수 있다. (행과 열이 만나는 시점) 따라서 해당 값보다 크게 되면, 가로로 배치되는 시점이므로 행의 위치는 sq+1로 고정이며 열의 위치는 sq+1의 제곱에서 k값을 뺀 값이 k가 위치하는 열의 번호가 된다. 또는 행과 열이 만나는 시점보다 k의 값이 작게 되면, 세로로 배치되는 시점이므로 열의 위치는 sq+1로 고정이며 행의 위치는 k에서 sq의 제곱을 뺀 값이 된다. 최종 코드12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;math.h&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int k; cin &gt;&gt; k; int sq = (int)sqrt(k); if(sq*sq == k) { cout &lt;&lt; sq &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt; endl; continue; } if(k &gt; sq*sq+sq) cout &lt;&lt; sq+1 &lt;&lt; &quot; &quot; &lt;&lt; sq-(k-(sq*sq)-sq)+2 &lt;&lt; endl; else cout &lt;&lt; k-(sq*sq) &lt;&lt; &quot; &quot; &lt;&lt; sq+1 &lt;&lt; endl; } return 0;} 느낀점어렵지 않았다. 간단한 공식을 알아내면 쉽게 풀 수 있는 문제였다.앞에서 뻘짓한게 아까웠다..","link":"/2021/08/25/codeforces-739-C/"},{"title":"Codeforces Round #739 (Div. 3) Problem. D (After contest)","text":"https://codeforces.com/contest/1560/problem/DCodeforces Round #739 (Div. 3) D. Make a Power of Two TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 1300 greedy math strings Attr SubNo SolveTime Time Memory Accept? -1 126372797 TIME OVER 233 ms 3700KB Accepted(Late) 문제 요약2의 제곱으로 만들어라. 정수 n이 주어지고, 다음과 같은 행동을 할 수 있다. 임의의 숫자 하나를 지울 수 있다 (만약 숫자가 하나밖에 남지 않았으면 “empty”가 된다) 오른쪽에 숫자 하나를 놓을 수 있다. 가장 왼쪽에 0이 있을 때, 0은 지워지지 않는다.예시) 301에서 3을 빼면, 1이 아닌 01이 된다 최소한의 행동만 하여 n을 2의 제곱으로 만들어라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 104)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= n &lt;= 109) Output각 Testcase 마다1개의 정수 m : 2의 제곱으로 만드는 최소 비용 문제 풀이처음엔 햇갈렸지만, 결국 string을 사용하여 노가다로 풀 수 있는 문제라는 사실을 깨닳았다. 하나의 문자를 구현하기 위해서는 구현할 문자와 비교해가면서 필요없는 숫자는 빼고, 필요한 숫자만 마지막에 더해주면 쉽게 구현을 할 수 있다.(비용은 언제나 최소비용이 든다) 또한 n의 최대 범위가 10의 9승이기 때문에, 아무리 비용이 많이 들어도 9 이상으로는 들지 않을 것이다.10의 9승 이하에서 모든 값을 지우고 1만 추가하면 최대 9의 비용이 나온다 처음엔 long long int의 최대 범위를 10의 19승까지 했지만, 잘못된 선택이였다. long long int의 범위를 잘못 알고 있었었다. 이부분에서 시간을 많이 잡아먹었다결국 long long int의 범위 문제였고, 범위를 10의 18승으로 줄여 문제를 해결했다. 최종 해설먼저 간단한 예외(n이 이미 2의 제곱일때)는 미리 검사하고 걸러냈다. 만약 그렇지 않으면, n을 string으로 바꿔서 시작한다. 그 뒤로 2의 제곱을 계속해서 비교해 가면서 최소비용을 계산을 한다.만약 비용이 1이 나오면, 1보다 작은 비용은 나오지 않기 때문에 검사를 종료하였다. 검사는 n의 digit들을 하나씩 돌아가면서 구현할 숫자와 비교를 한다.n과 다른 숫자가 있으면 해당 digit를 제거하고, n의 탐색이 먼저 끝나면 남은 digit들을 추가해주면 구현이 완료된다. n의 최대값은 109이므로 가장 큰 최소 비용은 9가 된다.10의 9승 이하에서 모든 값을 지우고 1만 추가하면 최대 9의 비용이 나온다그러므로 +-를 계산하여 구현해볼 최대의 2의 제곱수는 1018 까지 확인을 해 주었다. 최종 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;string&gt; using namespace std; bool CheckPow(int a) { while(a &gt; 1) { if(a % 2) return false; a/=2; } return true;} long long int Power(long long int a, long long int b) { long long int result = a; for(long long int i = 1; i &lt; b; i++) result = result * a; return result;} int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int n; cin &gt;&gt; n; if(CheckPow(n)) { cout &lt;&lt; 0 &lt;&lt; endl; continue; } string num = to_string(n); long long int now = 1; int result = 15; int weight = 9; //cout &lt;&lt; (long long int)powl(10, 20) &lt;&lt; endl; //cout &lt;&lt; Power(10, 18) &lt;&lt; endl; while (result &gt; 1 &amp;&amp; now &lt; Power(10, 18)) { string nstr = to_string(now); int i = 0, j = 0; int trash = 0; for(i = 0; i &lt; nstr.length(); i++) { for(j; j &lt; num.length(); j++) { if(nstr[i] == num[j]) break; trash++; } if(j==num.length()) { trash += nstr.length() - i; break; } else j++; } result = min(result, trash + (int)(num.length()-j)); now *= 2; } cout &lt;&lt; result &lt;&lt; endl; } return 0;} 느낀점처음 봤을 때 막막했지만, 오랜시간 고민해본 결과 해법을 알아내고 시간은 얼마 남지 않았었다.결국 오류를 잡지 못하고 대회가 종료되고 말았다. 결국 int의 범위 때문에 큰 오류가 났었는데, 다음부턴 최대값을 정하고 작업을 하는게 안전할 것 같다.","link":"/2021/08/25/codeforces-739-D/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"summary","slug":"summary","link":"/tags/summary/"},{"name":"Div.3","slug":"Div-3","link":"/tags/Div-3/"},{"name":"Problem Solve","slug":"Problem-Solve","link":"/tags/Problem-Solve/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Codeforces","slug":"Algorithm/Codeforces","link":"/categories/Algorithm/Codeforces/"},{"name":"Problems","slug":"Algorithm/Codeforces/Problems","link":"/categories/Algorithm/Codeforces/Problems/"}]}