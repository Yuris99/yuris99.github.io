{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Codeforces Round #739 (Div. 3) 리뷰","text":"알고리즘 공부를 열심히 하겠다고 마음먹은뒤 결국 Div. 2 하나를 놓치고 지나갔다.결국 바로 다음에 있는 Div. 3부터 치르게 되었는데, 오랜만이라 그런가 생각보다 쉽지 않았다.앞으로 알고리즘 공부한것들의 리뷰를 해볼생각이다. 실력이 조금이라도 늘겠지… Result # A B C D E F1 F2 Attr 1 3 1 0 - - - Attr* - - - 1 - - - Time 20 55 15 Over - - - Solve O O O Late - - - Adjustment Rating Ranking Tear 1023 (+49) 10341 (+3079) Newbie","link":"/2021/08/19/codeforces-739/"},{"title":"Codeforces Round #739 (Div. 3) Problem. C","text":"https://codeforces.com/contest/1560/problem/CCodeforces Round #739 (Div. 3) C. Infinity Table TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 implementation math Attr SubNo SolveTime Time Memory Accept? 1 126343911 +14min (70m) 30 ms 3600KB Accepted 문제 요약2차원배열 가장 왼쪽 위부터 시작하는 table이 있다. 이table은 다음과같은 패턴으로 순서대로 생성이 된다.위와같은 패턴으로 table이 무한정 생성될 때 k가 존재하는 행과 열을 구하여라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= k &lt;= 109) Output각 Testcase 마다2개의 정수 (r, c &gt;= 1) space로 구분 : k가 위치하고있는 열과 행 문제 풀이또 800점 문제이다. 또한 패턴만 구하면 간단하게 해결할 수 있었다. 0번째 열을 확인해보면 각각 n번째 행의 원소들이 n의 제곱인것을 확인할 수 있다.다르게 말하면 0번째 행의 0보다 큰 n번째 열의 원소는 n-1의 제곱 + 1이라는 사실도 성립된다.또한 변화하는 행과 열의 종류가 변경되는 시점은 n-1의 제곱 + (n-1)이기 때문에 k의 위치는 쉽게 구할 수 있었다. 최종 해설먼저 정수형 sq를 선언하여 k의 제곱근(소수점부분은 제외)을 구하였다. 만약 소수점을 제외한 sq의 제곱이 k와 같다면, k의 위치는 0열 sq행으로 고정되기 때문에 예외를 두어 처리를 해 주었다. 다음으로 알아야 하는것은 k가 위치하고 있는 곳이 열이 변경되는 구간인지, 행이 변경되는 구간인지 알 필요가 있다.먼저 행과 열이 바뀌는 구간은 sq의 제곱 + sq로 구할 수 있다. (행과 열이 만나는 시점) 따라서 해당 값보다 크게 되면, 가로로 배치되는 시점이므로 행의 위치는 sq+1로 고정이며 열의 위치는 sq+1의 제곱에서 k값을 뺀 값이 k가 위치하는 열의 번호가 된다. 또는 행과 열이 만나는 시점보다 k의 값이 작게 되면, 세로로 배치되는 시점이므로 열의 위치는 sq+1로 고정이며 행의 위치는 k에서 sq의 제곱을 뺀 값이 된다. 최종 코드12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;math.h&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int k; cin &gt;&gt; k; int sq = (int)sqrt(k); if(sq*sq == k) { cout &lt;&lt; sq &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt; endl; continue; } if(k &gt; sq*sq+sq) cout &lt;&lt; sq+1 &lt;&lt; &quot; &quot; &lt;&lt; sq-(k-(sq*sq)-sq)+2 &lt;&lt; endl; else cout &lt;&lt; k-(sq*sq) &lt;&lt; &quot; &quot; &lt;&lt; sq+1 &lt;&lt; endl; } return 0;} 느낀점어렵지 않았다. 간단한 공식을 알아내면 쉽게 풀 수 있는 문제였다.앞에서 뻘짓한게 아까웠다..","link":"/2021/08/25/codeforces-739-C/"},{"title":"Codeforces Round #739 (Div. 3) Problem. A","text":"https://codeforces.com/contest/1560/problem/ACodeforces Round #739 (Div. 3) A. Dislike of Threes TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 implementation Attr SubNo SolveTime Time Memory Accept? 1 126297598 20min 31 ms 3660KB Accepted 문제 요약Polycarp은 3을 싫어한다. 3으로 끝나는 문자와 3으로 나누어 떨어지는 문자를 제외하고 숫자를 세어서 n번째 숫자를 구해라 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= k &lt;= 1000) Output각 Testcase 마다1개의 정수 x : Polycarp이 싫어하지 않는 k-th 숫자 문제 풀이정말 간단하게 풀 수 있다. 단순한 1차원 반복문을 사용하여 num이 3으로 나누어떨어지거나 3으로 끝나면(10으로 나누었을때 나머지가 3이면) 한번 더 더해서 카운트를 건너뛰어주었다. 최종 코드123456789101112131415161718192021#include &lt;iostream&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int k; cin &gt;&gt; k; int num = 0; for(int i = 1; i &lt;= k; i++) { num++; while(num % 3 == 0 || num % 10 == 3) num++; } cout &lt;&lt; num &lt;&lt; endl; } return 0;} 느낀점800점대 문제면서 Div. 3 A번 문제라 정말 쉬웠다. 간단한 루프문으로 해결될줄은 몰랐지만 생각보다 빠르게 끝냈다.","link":"/2021/08/21/codeforces-739-A/"},{"title":"Codeforces Round #739 (Div. 3) Problem. B","text":"https://codeforces.com/contest/1560/problem/BCodeforces Round #739 (Div. 3) B. Who’s Opposite? TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 math Attr SubNo SolveTime Time Memory Accept? 1 126327661 +40min 1000 ms 3700KB Time limit 2 126332184 +8min (48m) 77 ms 3600KB Wrong answer 3 126336434 +8min (56m) 93 ms 3700KB Accepted 문제 요약원형의 식탁에서 회의를 하는데 인원은 모르고(짝수이다) 모든 사람은 서로 마주보는 상대가 있다.각자의 번호는 1부터 시작해서 시계방향으로 숫자를 매긴다.a 와 b가 마주보고 있을 때, c와 마주보고 있는 사람의 번호를 구하여라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 104)각 Testcase 마다t-th line : space로 구분된 3개의 정수 (1 &lt;= a, b, c &lt;= 108) Output각 Testcase 마다1개의 정수 d : c와 마주보고있는 숫자답이 여러개일시 아무거나 출력, 답이 없으면 -1출력 문제 풀이이문제 또한 어려운 문제는 아니였다. 규칙만 잘 찾으면 되는 문제였지만, 예상외로 해맸었다. Attr 1 (Time Limit exceeded on test 2)첫시도부터 굉장히 복잡하게 생각을 했는데 일단 무조건 규칙이 있을것이라고 예상을 하였다. 그래서 열심히 규칙을 찾아본 결과..서로 마주보는 a와 b를 기준으로 a-n은 b-n을 마주보고 있다는 사실을 알게 되었다.또한 계속 빼가다가 어느 한 수가 0에 도달하게 되면, 큰수 + (큰수 - n - 작은수)가 원탁에 앉아있는 총 인원 수가 나왔다. 복잡하다또는 큰수-n과 작은수의 값이 같아지면, 큰수 + (작은수 - n) 의 값이 총 인원수가 되었다. 결국 for문으로 돌려서 위 두 케이스중 하나의 케이스가 나오게 되면 Loop를 빠져나가고 남은 값들을 계산하여 값을 도출해 냈다. 물론 결과는 시간 초과최대 시간복잡도가 104X108 = 1012(약 1조…)가 나와버린다… 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); int i, meet = small - 1; int result = -1; for (i = big-1; i &gt; small &amp;&amp; meet &gt; 0; i--, meet--) { if (result == -1) { if(i == c) result = meet; else if(meet == c) result = i; } } //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;, m = &quot; &lt;&lt; meet &lt;&lt; endl; if(result == -1 &amp;&amp; i &gt; small &amp;&amp; meet == 0) { if(c &gt; small &amp;&amp; c &lt;= i) result = big + (c-small); else if(c &gt; big &amp;&amp; c &lt;= (big + (i-small))) result = small + (c-big); } cout &lt;&lt; result &lt;&lt; endl; } return 0;} Attr 2 (Wrong answer on test 2)시간초과로 한대 맞고난 뒤 for문으로 해결할 수 없는 문제라는 사실을 문제를 본지 40분만에 알아차렸다. 결국 다른 규칙을 찾다가 한가지 핵심적인 규칙을 깨닳을 수 있었다. 서로 마주보고있는 두 수의 간격은 무조건 전체 인원수의 절반이 된다.이 규칙을 찾은 후 이 규칙을 가지고 코드를 짰다. 기본적으로 두 수의 간격을 구하고, 그 간격을 기준으로 c값이 작으면 전체 인원수의 절반을 더해주고, c값이 크면 전체 인원수의 절반을 빼주는 형식으로 정답을 구했다. 또한 몇가지의 예외사항을 넣어두었다. 앞에서 했던 for문 뻘짓을 왜했는지 이해가 되지 않았지만 8분만에 코드를 짜고 제출을 하였다.그러나 결과는 오답공식에는 문제가 없었다. 다른 예외사항이 있는듯했다. 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c, result = -1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); int dis = big - small; if(c &gt; dis) result = c-dis; else if (c &lt;= dis) result = c + dis; if(result &gt; dis*2 || big &gt; dis*2) result = -1; cout &lt;&lt; result &lt;&lt; endl; } return 0;} Attr 3 (Accepted!)결국 또하나의 예외를 찾아내고 나서야 문제를 해결할 수 있었다. “c가 전체 인원수보다 크면: a와 b가 마주보고 있는 원탁에는 c는 존재할 수 없다.”결론적으로 이 예외조건을 추가하니 정상적으로 코드가 Accept 되었다. 최종 해설서로 마주보고있는 두 수의 간격은 무조건 전체 인원수의 절반이 된다. a와 b를 사용하여 전체 인원수의 절반을 구하고, 그 수를 기준으로 하여 c에 따라서 결과값을 구해주면 된다.규칙만 잘찾으면 어렵지않게 풀 수 있는 문제였다. 괜히 반복문으로 접근해서 시간만 날렸다 ?c가 전체 인원수의 절반보다 작거나 같으면: 정답 : c + 전체 인원수의 절반; ?아니면 c가 전체 인원수의 절반보다 크면: 정답 : c - 전체 인원수의 절반; 만약: 정답이 전체 인원수보다 크면: 정답 : -1; 제대로된 원탁이 아니다. 또는: c가 전체 인원수보다 크면: 정답 : -1; a와 b가 마주보고 있는 원탁에는 c는 존재할 수 없다. 또는: a와 b중에 큰 수가 전체 인원수보다 크면: 정답 : -1; a와 b중에 큰 수는 제대로된 원탁에 존재할 수 없다. 최종 코드12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c, result = -1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); //총 인원수의 절반 int dis = big - small; if(c &gt; dis) result = c-dis; else if (c &lt;= dis) result = c + dis; //답이 나오지 않는 경우 if(result &gt; dis*2 || big &gt; dis*2 || c &gt; dis*2) result = -1; cout &lt;&lt; result &lt;&lt; endl; } return 0;} 느낀점원형탁자 -&gt; 숫자 -&gt; 순서대로 -&gt; 반복문!! 일것이라고 안일하개 생각한게 문제가 되었다.결국 초반에 반복문으로 계속 고민을 하다가 시간만 날려버리게 되었다.문제를 해결하는 방법에 편견을 가지지 말고 다양한 방법을 생각해 봐야할 것 같다.","link":"/2021/08/23/codeforces-739-B/"},{"title":"Codeforces Round #739 (Div. 3) Problem. D (After contest)","text":"https://codeforces.com/contest/1560/problem/DCodeforces Round #739 (Div. 3) D. Make a Power of Two TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 1300 greedy math strings Attr SubNo SolveTime Time Memory Accept? -1 126372797 TIME OVER 233 ms 3700KB Accepted(Late) 문제 요약2의 제곱으로 만들어라. 정수 n이 주어지고, 다음과 같은 행동을 할 수 있다. 임의의 숫자 하나를 지울 수 있다 (만약 숫자가 하나밖에 남지 않았으면 “empty”가 된다) 오른쪽에 숫자 하나를 놓을 수 있다. 가장 왼쪽에 0이 있을 때, 0은 지워지지 않는다.예시) 301에서 3을 빼면, 1이 아닌 01이 된다 최소한의 행동만 하여 n을 2의 제곱으로 만들어라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 104)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= n &lt;= 109) Output각 Testcase 마다1개의 정수 m : 2의 제곱으로 만드는 최소 비용 문제 풀이처음엔 햇갈렸지만, 결국 string을 사용하여 노가다로 풀 수 있는 문제라는 사실을 깨닳았다. 하나의 문자를 구현하기 위해서는 구현할 문자와 비교해가면서 필요없는 숫자는 빼고, 필요한 숫자만 마지막에 더해주면 쉽게 구현을 할 수 있다.(비용은 언제나 최소비용이 든다) 또한 n의 최대 범위가 10의 9승이기 때문에, 아무리 비용이 많이 들어도 9 이상으로는 들지 않을 것이다.10의 9승 이하에서 모든 값을 지우고 1만 추가하면 최대 9의 비용이 나온다 처음엔 long long int의 최대 범위를 10의 19승까지 했지만, 잘못된 선택이였다. long long int의 범위를 잘못 알고 있었었다. 이부분에서 시간을 많이 잡아먹었다결국 long long int의 범위 문제였고, 범위를 10의 18승으로 줄여 문제를 해결했다. 최종 해설먼저 간단한 예외(n이 이미 2의 제곱일때)는 미리 검사하고 걸러냈다. 만약 그렇지 않으면, n을 string으로 바꿔서 시작한다. 그 뒤로 2의 제곱을 계속해서 비교해 가면서 최소비용을 계산을 한다.만약 비용이 1이 나오면, 1보다 작은 비용은 나오지 않기 때문에 검사를 종료하였다. 검사는 n의 digit들을 하나씩 돌아가면서 구현할 숫자와 비교를 한다.n과 다른 숫자가 있으면 해당 digit를 제거하고, n의 탐색이 먼저 끝나면 남은 digit들을 추가해주면 구현이 완료된다. n의 최대값은 109이므로 가장 큰 최소 비용은 9가 된다.10의 9승 이하에서 모든 값을 지우고 1만 추가하면 최대 9의 비용이 나온다그러므로 +-를 계산하여 구현해볼 최대의 2의 제곱수는 1018 까지 확인을 해 주었다. 최종 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;string&gt; using namespace std; bool CheckPow(int a) { while(a &gt; 1) { if(a % 2) return false; a/=2; } return true;} long long int Power(long long int a, long long int b) { long long int result = a; for(long long int i = 1; i &lt; b; i++) result = result * a; return result;} int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int n; cin &gt;&gt; n; if(CheckPow(n)) { cout &lt;&lt; 0 &lt;&lt; endl; continue; } string num = to_string(n); long long int now = 1; int result = 15; int weight = 9; //cout &lt;&lt; (long long int)powl(10, 20) &lt;&lt; endl; //cout &lt;&lt; Power(10, 18) &lt;&lt; endl; while (result &gt; 1 &amp;&amp; now &lt; Power(10, 18)) { string nstr = to_string(now); int i = 0, j = 0; int trash = 0; for(i = 0; i &lt; nstr.length(); i++) { for(j; j &lt; num.length(); j++) { if(nstr[i] == num[j]) break; trash++; } if(j==num.length()) { trash += nstr.length() - i; break; } else j++; } result = min(result, trash + (int)(num.length()-j)); now *= 2; } cout &lt;&lt; result &lt;&lt; endl; } return 0;} 느낀점처음 봤을 때 막막했지만, 오랜시간 고민해본 결과 해법을 알아내고 시간은 얼마 남지 않았었다.결국 오류를 잡지 못하고 대회가 종료되고 말았다. 결국 int의 범위 때문에 큰 오류가 났었는데, 다음부턴 최대값을 정하고 작업을 하는게 안전할 것 같다.","link":"/2021/08/25/codeforces-739-D/"},{"title":"Codeforces Round #740 (Div. 2) Problem. A","text":"https://codeforces.com/contest/1561/problem/ACodeforces Round #740 (Div. 2, based on VK Cup 2021 - Final (Engine)) A. Simply Strange Sort TimeLimit MemoryLimit Difficulty Tags 2 S 512 MB 800 brute force implementation sortings Attr SubNo SolveTime Time Memory Accept? 1 126892151 20min 31 ms 3600KB Wrong answer 2 126900288 +25min (45m) 46 ms 3700KB Accepted 문제 요약조금 이상한 정렬.. n개의 원소를 가지고있는 배열 a(n개의 원소를 가진 배열, n: 홀수)이 주어진다.배열 a를 오름차순으로 정렬한다. 알고리즘: f(i)를 수행한다.i는 (1 &lt;= i &lt;= n-1)사이로 수행되고, 각 다음과 같은 알고리즘을 사용한다 : 만약 **ai &gt; ai+1**이면, **ai 와 ai+1의 값을 변경한다. 알고리즘은 반복으로 구성되고, 숫자 1부터 시작한다. i번째 반복일 때, 다음과 같은 알고리즘을 수행한다 만약 i가 홀수이면: f(1), f(3),…,f(n-2);를 호출 만약 i가 짝수이면: f(2), f(4),…,f(n-1);를 호출 배열이 오름차순으로 정렬될 때까지 반복한다. 몇번의 반복을 해야 오름차순으로 정렬되는지 구하는 문제… 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다 1-st line : 1개의 정수 (1 &lt;= n &lt;= 1000, n: 홀수) 2-nd line : n개의 정수 a1, a2…,an (1 &lt;= ai &lt;= n) 모든 테스트케이스의 n의 합이 999를 넘지 않는다. Output각 Testcase 마다최초로 오름차순으로 정렬이 되는 최소 반복 횟수를 출력 이미 정렬이 되어있다면, 0을 출력 문제 풀이그냥 무시정으로 반복해도 해결할 수 있는 문제이다. 알고리즘도 다 알려주고 위에서 시키는대로 코드를 짜기만 하면 되는 문제 Attr 1 (Wrong answer on pretest 2)처음에는 checkSorted라는 변수를 하나 만들어서 반복문 안에서 변경되는 점이 있으면 checkSorted를 꺼주고, checkSorted가 꺼지지 않으면 정렬이 된것으로 보고 반복문을 탈출시켜주는 코드였다. 에러가 떴다. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int result = 0; int n, arr[1001]; cin &gt;&gt; n; arr[0] = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; arr[i]; } while(true) { result ++; int checkSorted = true; for(int i = (result%2==0?2:1); i &lt; n; i+=2) { if(arr[i] &gt; arr[i+1]) { //cout &lt;&lt; &quot;exchange &quot; &lt;&lt; arr[i] &lt;&lt; &quot; and &quot; &lt;&lt; arr[i+1] &lt;&lt; endl; int temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; checkSorted = false; } if(arr[i-1] &gt; arr[i]) checkSorted = false; } if(checkSorted) break; } cout &lt;&lt; result - 1 &lt;&lt; endl; } return 0;} Attr 2 (Accepted!)에러가 날만한 테스트 케이스를 하나씩 넣어봤는데 바로 발견할 수 있었다. 1251 2 3 5 4 위의 케이스를 넣었을때, 확인이 되지않고 0으로 출력이 되었다.바로 해결할 수 있는 문제였는데, 햇갈려서 알고리즘을 다시 짜는 수준까지 가버렸다. 시간이 더 걸리더라도 그냥 배열이 정렬되었는지 미리 확인을 하는 코드를 추가했는데, 시간제한이 넉넉하다보니 문제없이 잘 작동하였었다. 바로 해결하지 못한 이유는 위 케이스의 답이 2가아닌 1이라 생각하고 삽질하고 있었다… 최종 해설위의 해설이랑 똑같이 만들었다. n을 먼저받고, 문제에서 1부터 시작했기 때문에 햇갈리지 않기 위해서 배열의 0은 0으로 채워주고 1부터 입력값을 받아주었다. (1~`n`) 그다음 정렬이 될 때까지 무한반복을 해주는데, 먼저 배열이 정렬되었는지 확인을 해준다. 단순히 for문으로 반복하면서 비교를 해주었다. 정렬이 되지않았으면 result값을 1 더해주고 문제에 나온 알고리즘을 수행해준다. 이렇게 반복하면 어렵지 않게 답을 구할 수 있다. 최종 코드12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int result = 0; int n, arr[1001]; cin &gt;&gt; n; arr[0] = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; arr[i]; } while(true) { //check if array sorted int i = 1; for(i; i &lt; n; i++) if(arr[i] &gt; arr[i+1]) break; if(i == n) break; result ++; for(int i = (result%2==0?2:1); i &lt; n; i+=2) { if(arr[i] &gt; arr[i+1]) { //cout &lt;&lt; &quot;exchange &quot; &lt;&lt; arr[i] &lt;&lt; &quot; and &quot; &lt;&lt; arr[i+1] &lt;&lt; endl; int temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; } } } cout &lt;&lt; result &lt;&lt; endl; } return 0;} 느낀점알람은 미리미리 맞춰놓자.정신좀 차리자.","link":"/2021/08/25/codeforces-740-A/"},{"title":"Codeforces Round #740 (Div. 2) 리뷰","text":"서론Codeforces Round #740 (Div. 2, based on VK Cup 2021 - Final (Engine))VK Cup의 최종 문제를 기준으로 출제된 Contest이다. 사실 뭔지 잘 모르지만, 확실한건 내가 알람을 맞춰두지 않았다는 사실이다. 문제를 풀기 시작한 시점은 1시간이 남았을때였다. 2점밖에 올리지 못했는데 1887등이 올랐다…. 이것이 심해인가보다 Result # A B C D E F1 F2 Attr 2 - - - - - - Attr* - - - - - - - Time 45 - - - - - - Solve O - - - - - - Adjustment Rating Ranking Tear 1025 (+2) 8454 (+1887) Newbie","link":"/2021/08/25/codeforces-740/"},{"title":"[강의정리] 데이터통신과네트워크 OT","text":"수업 개요 TCP/IP 모델을 사용하여 인터넷이 동작하는 원리를 학습 수업 교재 Computer Networking: A Top-Down Approach, 7th Edition (Pearson) James Kurose and Keith Ross 교재에 포함되지 않는 내용은 강의교안을 통해 제공 중간 기말 일정 중간시험 (8주차) 2021년 10월 21일 목요일 오후 7시 (오프라인) 기말시험 (15주차) 2021년 12월 9일 목요일 오후 7시 (오프라인) 성적 처리 중간/기말 시험 60% 기말시험범위: 전범위 과제물 제출 30% 퀴즈 및 과제 포함 출석 및 수업태도 10%","link":"/2021/09/06/dataNetwork-W1-OT/"},{"title":"[강의정리] 데이터통신과네트워크 Overview(2)","text":"네트워크 계층 구조네트워크 계층 구조: 네트워크 계층네트워크 계층 프로토콜: ARP (Address Resolution Protocol) 데이터를 전달하려는 IP 주소와 통신에 필요한 물리적인 주소(MAC)를 알아내는 프로토콜 선택된 매체에 브로드캐스트를 통해 특정 IP 주소를 사용하는 호스트가 응답을 하도록 요구하는 방식을 사용 네트워크 계층 프로토콜: IP (Internet Protocol) 가장 대표적인 네트워크 계층의 프로토콜 하위 계층의 서비스를 이용하여 두 노드 간의 데이터 전송 경로를 확립해주는 역할 (단말장치 간 패킨 전송 서비스) IP (Internet Protocol)주소 체계 32자리 2진수로, 8자리마다 점을 찍어 구분 A, B, C, D, E 클래스로 구분하는데 각 클래스는 네트워크 부분과 호스트 부분으로 구성 A, B, C 클래스는 맨 앞부분에 시작하는 2진수 숫자에 따라 구분 IP (Internet Protocol)주소 분류 사설 네트워크: 사설 네트워크는 공인 네트워크 주소 부족 현상을 해결하기 위해 많이 사용 네트워크 계층 프로토콜: ICMP (Internet Control Message Protocol) 호스트 서버와 인터넷 게이트웨이 사이에서 메시지를 제어 및 오류를 알려주는 프로토콜 대표적인 툴은 ping ICMP Echo Request 메시지 송신측의 전송 패킷이 목적이 노드나 라우터에 도착했는지를 확인하는 데 사용 네트워크 계층 프로토콜: IGMP (Internet Group Management Protocol) 멀티캐스트에 관여하는 프로토콜로 멀티캐스트 그룹을 관리하는 역할 유니캐스트(Unicast) - 일반적, 브로드캐스트(Broadcast), 멀티캐스트(Multicast) - 중간 / 효율높음 IP 멀티캐스트 주소는 D 클래스 주소 대역(244.0.0.1 ~ 239.255.255.255)으로 규정 네트워크 계층 관련 장비: 라우터 네트워크의 대표적인 장비, 게이트웨이라고도 함 논리적으로 분리된 둘 이상의 네트워크를 연결 로컬 네트워크에서 브로드캐스트를 차단하여 네트워크를 분리 패킷이 목적지까지 가장 빠르게 보내는 길잡이 역할 정적 라우팅 관리자 권환으로 특정 경로를 통해서만 패킷이 지날 수 있도록 설정 네트워크 변경사항이 발생하면 라우팅 테이블을 수동으로 직접 고쳐야 함 보안이 중요한 경우 선호 동적 라우팅 라우터가 네트워크 연결 상태를 스스로 파악하여 최적의 경로를 선택해 전송 네트워크 연결 형태가 변경되어도 자동으로 문제를 해결 네트워크 계층 구조: 전송 계층4계층: 전송 계층(Transport Layer) 프로토콜(TCP, UDP)과 관련된 계층으로 오류 복구와 흐름 제어 등을 담당, 두 시스템 간에 신뢰성 있는 데이터를 전송 네트워크 계층에서 온 데이터를 세션 계층의 어느 어플리케이션에 보낼 것인지 판독, 전송할 경로(Port, 포트)를 선택 네트워크 계층에서 전송한 데이터와 실제 운영체제의 프로그램이 연결되는 통신 경로라고 할 수 있음 대표 프로토콜은 TCP(Transmission Control Protocol) TCP가 가진 주소를 포트(Port)라 하며 0~65532(216-1)번까지 존재 -~1023번(1,024)d을 잘 알려진 포트(Well Known Port)라고 부름 (보통 0번 포트는 사용하지 않음) 포트 주소 수신지 컴퓨터까지 전송하려면 IP 주소와 물리 주소의 포트주소도 필요함! 인터넷 통신의 최종 목적은 한 프로세스가 다른 프로세스와 통신할 수 있도록 하는 것 즉 포트는 Tcp가 상위 계층으로 데이터를 전달하거나 상위 계층에서 TCP로 데이터를 전달할 때 상호 간에 사용하는 데이터의 이동 통로를 말함 전송 계층 프로토콜: TCP(Transmission Control Protocol) 연결 지항형 프로토콜 IP와 함께 통신을 하는 데 반드시 필요한 가장 기본적인 프로토콜 TCP의 특징 높은 신뢰성 가상 회선 연결 방식 연결의 설정과 해제 데이터 체크섬 시간 초과와 재전송 데이터 흐름 제어 연결 설정 과정(Three-Way Handshaking) 연결 해제 과정 전송 계층 프로토콜: UDP(User Datagram Protocol) 비연결 지향형 프로토콜 상대방이 보낸 응답을 확인하지 않아 네트워크에 부하를 주지 않음 데이터 자체의 신뢰성이 없어 수신한 데이터의 무결성을 보장받지 못함 UDP의 특징 비연결 지향형 네트워크 부하 감소 비신뢰성 전송된 데이터의 일부가 손실됨 네트워크 계층 구조: 세션 계층5계층: 세션 계층(Session Layer) 응용 프로그램 계층 사이의 접속을 설정 · 유지 · 종료시켜주는 역할 통신장치간의 설정을 유지하고 동기화 하는 역할 네트워크 계층 구조: 표현 계층6계층: 표현 계층(Presentation Layer) 데이터 표현 차이를 해결하려고 서로 다른 형식으로 변환하거나 공통 형식을 제공하는 계층 네트워크 계층 구조: 응용 계층7계층: 응용 계층(Application Layer) 여러가지 프로토콜에 대하여 사용자인터페이스를 제공 응용 계층(Application Layer) 관련 프로토콜들FTP(File Transfer Protocol, 20,21) 파일 전송을 위한 가장 기본적인 프로토콜 1972 년 텔넷과 함께 표준으로 제정 클라이언트와 서버가 대화형으로 통신 가능 Telnet(텔넷, 23) 사용자가 원격에 있는 서버에 로그인하도록 TCP 연결을 설정 단말기가 원격 컴퓨터 바로 옆에 있는 것처럼 직접 조작할 수 있게 해줌 POP3 &amp; IMAP POP3(110) : 메일 서버로 전송된 메일을 확인할 때 사용하는 프로토콜 IMAP(143) : POP3 와 기본적으로 같으나 , 메일을 읽은 후 메일이 서버에 남음 SMTP(Simple Mail Transfer Protocol, 25) 메일 서비스 DNS(Domain Name System, 53) 도메인 이름 주소를 통해 IP 주소를 확인할 수 있는 프로토콜 TFTP(Trivial File Transfer Protocol, 69) 파일을 전송하는 프로토콜 UDP 패킷을 사용하고 , 인증 기능을 제공하지 않음 HTTP( HyperText Transfer Protocol, 80) 인터넷을 위해 사용하는 가장 기본적인 프로토콜 네트워크 장비 네트워크 장비: 스위치 종류 L2 스위치: MAC 정보 기반 네트워크 통신 지원 L3 스위치: IP 정보 기반 네트워크 통신 지원 L4 스위치: IP 정보 + 포트정보 기반 네트워크 통신 지원 L7 스위치: Application Data 기반 네트워크 통신 지원 기본적인 네트워크의 구성","link":"/2021/09/14/dataNetwork-W2/"},{"title":"[강의정리] 데이터통신과네트워크 Overview","text":"네트워크의 이해네트워크의 사전적 의미 여러한 통신설비를 통해서 두대 이상의 컴퓨터를 서로 연결하는것 다수의 컴퓨터를 네트워크로 연결했을 때 얻을 수 있는 이점 데이터 공유가 용이함 (NAS) 주변장치 공유 (프린터) 눙률적인 통신 (메일) 근거리통신 (Local Area Network)근거리 통신망 (LAN, Local Area Network) 한 건물이나 학교 내 캠퍼스처럼 비교적 가까운 지역에 한정된 통신망 광역통신 (Wide Area Network)광역 통신망 (WAN) 두 개 이상의 근거리 네트워크가 넓은 지역에 걸쳐 연결되어 있는 것 WAN은 하나의 국가 또는 국가와 국가 간을 연결하는 매우 범위가 넓은 네트워크 우리가 매일 사용하는 인터넷 통신방식클라이언트/서버 시스템 다른 컴퓨터에 데이터 전송 서비스를 제공하는 컴퓨터를 ‘서버’라 하고, 서버에서 보내주는 데이터서비스를 수신하는 컴퓨터를 ‘클라이언트’라고 한다. 유니캐스트 네트워크에서 가장 많이 사용하는 방식 서버와 클라이언트 간의 일대일(1:1) 통신 방식 클라이언트의 IP주소와 MAC주소가 필요 브로드캐스트 로컬 LAN(라우터로 구분된 공간)에 있는 모든 네트워크 단말기에 데이터를 보내는 방식 서버와 클라이언트간에 일대모두(1:모두)로 통신하는 데이터 전송 서비스 브로드캐스트의 MAC주소는 FF-FF-FF-FF-FF-FF로 미리 정해져 있다. 다른 라우터를 찾거나, 라우터끼리 데이터를 교환하거나, 서버가 서비스를 제공하려고 모든 클라이언트에게 알릴 때 등 여러 상황에서 사용 하지만 불특정 다수에게 전송되는 서비스라 수신을 원치않는 클라이언트도 수신하므로 네트워크 성능 저하를 가져올 수 있다. 멀티캐스트 브로드캐스트는 데이터를 무조건 CPU로 전송하기 때문에 컴퓨터 자체의 성능을 떨어뜨림 멀티캐스트는 전송하려는 특정 그룹에게만 한 번에 전송할 수 있기 때문에 유니캐스트처럼 반복해서 보낼 필요가 없고, 브로드캐스트처럼 전송받을 필요가 없는 컴퓨터에 보내지 않아도 됨 프로토콜 (Protocol)프로토콜에 대한 이해 본래의 의미는 외교에서 의례 또는 의정서 톰 마릴이 컴퓨터와 컴퓨터 사이에서 메시지를 전달하는 과정이라 정의 프로토콜의 3가지 요소 구문(Syntax): 데이터의 구조나 포멧을 의미 의미(Semantics): 전송되는 데이터의 각 부분이 무엇을 뜻하는지를 알 수 있게 미리 정해둔 규칙(데이터 자체뿐만 아니라 오류 제어, 동기 제어, 흐름 제어를 포함) 순서(Timing): 어떤 데이터를 보낼 것인지와 얼마나 빠르게 데이터를 보낼 것인지 정의 프로토콜의 기능주소 설정(Addressing) 서로 다른 시스템의 두 개체가 통신을 하는경우 필요 순서 제어(Sequence Control) 프로토콜 데이터 단위를 전송할 때 보내는 순서를 명시하는 기능(연결 지향형 (Connection-Oriented)에서만 사용) 데이터 대열의 단편화 및 재조합(Fragmentation &amp; Reassembly) 대용량 파일을 전송할 때 전송 효율이 높은 작은 단위로 나누어 전송한 뒤 전송 받은 시스템에서 이를 재조합 해야 함 어떻게 쪼갤건지, 재조합 할건지 캡슐화(Encapsulation) 데이터에 제어 정보를 추가 연결 제어(Connection Control) 연결 설정, 데이터 전송, 연결 해제에 대한 통제 수행 흐름 제어(Flow Control) 송신측 개체로부터 오는 데이터의 양이나 속도를 조절하는 기능 송신측과 수신측의 속도 차이 등으로 인한 정보 유실을 방지 오류 제어(Error Control) 두 개체에서 데이터를 교환할 때 오류가 발생할 경우, 이를 제어하는 기법 순서를 검사하거나 특정 시간 안에 받지 못하면 재전송을 요구하는 방식 동기화(Synchronization) 두 개체 간에 데이터를 전송할 때 각 개체는 특정 타이머 값이나 윈도우 크기 등을 통해 동시에 정의된 인자 값을 공유하는 것 다중화(Multiplexing) 통신 선로 하나에서 여러 시스템을 동시에 통신할 수 있는 기법 전송 서비스 우선순위 결정, 서비스 등급과 보안 요구 등을 제어하는 서비스 네트워크 계층 구조네트워크 계층화에 대한 이해 1980년대 초 ISO(International Organization for Standardization)은 여러 업체가 만든 시스템에 대해 상호 연동이 가능한 표준 네트워크 모델을 제정할 필요성을 인식 1984년 OSI(Open System Interconnection) 네트워크 모델을 발표 OSI 7계층 모델 OSI 7계층물리 계층: 1계층 실제 장치를 연결하는데 필요한 전기적, 물리적 세부 사항을 정의 물리 계층의 장치로는 허브나 리피터가 있음 데이터 링크 계층: 2계층 점대점(Point-to-Point) 사이의 신뢰성 있는 전송을 보장하기 위한 계층 CRC 기반의 오류 제어와 흐름 제어가 필요 가장 잘 알려진 예는 이더넷 네트워크 계층: 3계층 여러 노드를 거칠 때마다 경로를 찾아주는 역할 라우팅, 흐름 제어, 단편화(Segmentation/Desegmentation), 오류 제어 등을 수행 대표적인 예는 라우터임, 또한 3계층에서 동작하는 스위치를 흔히 L3 스위치라 함. 전송 계층: 4계층 양 끝단 사용자들이 신뢰성 있는 데이터를 주고받을 수 있게 하여 상위 계층이 데이터 전달의 유효성이나 효율성을 고려하지 않아도 되게 해줌. 전송 계층에서 동작하는 프로토콜 중 TCP는 연결 지향(Connetion-Oriented) 프로토콜임 세션 계층: 5계층 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공 TCP/IP 세션을 만들고 없애는 책임을 짐. 표현 계층: 6계층 시스템에서 사용되는 코드 간의 번역을 담당 표현 계층은 data의 Format(형식)을 정의함 응용 계층: 7계층 사용자나 응용 프로그램 사이에 데이터 교환을 가능하게 하는 계층 HTTP, FTP, 터미널 서비스, 메일 프로그램, 디렉토리 서비스 등을 제공 TCP/IP 4계층 OSI 7계층 vs. TCP/IP 4계층 OSI는 개념적인 모델 (실제 구현에서 반드시 지킨다고 볼 수 없음) TCP/IP 프로토콜은 OSI 모델보다 먼저 개발됨 TCP/IP 프로토콜의 계층은 OSI 모델의 계층과 정확히 일치하지 않음 두 계층을 비교할 때, 세션(Session)과 표현(Presentation) 2개의 계층이 TCP/IP프로토콜 그룹에 없다는 것을 알 수 있음 OSI 7 Layer는 장비 개발과 통신 자체를 어떻게 표준으로 잡을지 사용되는 반면에 실질적인 통신 자체는 주로 TCP/IP 프로토콜을 사용함 최근에는 TCP/IP 모델을 5계층으로 분류하기도 함 네트워크 계층 구조: 물리 계층1계층: 물리 계층(Physical Layer) 두 시스템 간에 데이터를 전송하려고 링크를 활성화하고 관리하는 전기적 · 기계적 · 절차적 · 기능적 특성 등을 정의 OSI 참조 모델 7계층 중 물리 계층은 최하위 계층인 첫 번째 계층으로, 상위 계층에서 전송된 데이터를 물리매체를 통해 다른 시스템에 전기적 신호로 전송 LAN 카드, 케이블, 허브, 라우터 등 물리적인 것과 데이터 전송에 사용하는 전압 등 기본적인 것들이 물리계층에 속함. 송신 측: 데이터 링크 계층에서 0과 1로 구성된 비트열의 데이터(프레임)을 받아 전기적 신호로 변환한 후 전송매체를 통하여 수신측에 보냄 수신 측: 송신측에서 받은 전기 신호를 0과 1로 구성된 비트열로 복원, 수신측의 데이터 링크 계층에 전송 물리 계층 관련 장비리피터(Repeater) 네트워클르 연장하기 위한 장비 불분명해진 신호 세기를 다시 증가시키는 역할 최근 리피터가 모든 네트워크 장비에 공통으로 들어가는 기능이 됨. 허브(Hub) 요즘 쓰이는 스위치의 예전 형태 허브는 스위치와 형태나 사용 방법이 같지만 패킷을 모든 곳에 똑같이 복사해서 보내는 것이 다름(스위치는 목적지에만 데이터를 전송) 네트워크 계층 구조: 데이터 링크 계층2계층: 데이터 링크 계층(Data Link Layer) 물리적 링크를 이용하여 신뢰성 있는 데이터를 전송하는 계층 네트워크를 통해 데이터를 전송할 때 전송로 역할 데이터 링크 계층은 비트를 프레임이라는 논리적 단위로 구성 시스템 간에 오류 없이 데이터를 전송하려고 **네트워크 계층에서 받은 데이터 단위(패킷)를 프레임으로 구성하여 물리 계층으로 전송 데이터 링크 계층의 물리적인 주소: 랜카드나 네트워크 장비의 하드웨어 주소(MAC 주소) 네트워크 카드의 MAC 주소는 윈도우 명령 창에서 ‘ipconfig /all’ 명령을 실행하면 ‘Physical Address’ 에서 확인 가능 리눅스 Machine의 경우 ifconfig 명령어 MAC 주소 총 12개의 16진수로 구성 앞쪽 6개는 네트워크 카드를 만든 회사(OUI: Organizationally Unique Identifier)를 뜻하고, 뒤쪽 6개는 호스트 식별자(Host Identifier)로 각 회사에서 임의로 붙이는 일종의 시리얼 같은 MAC 주소는 존재하지 않음 데이터 링크 계층 프로토콜: 이더넷 제록스의 PARC(Palo Alto Research Center)에서 1970년대에 개발한 데이터 링크 계층의 프로토콜 CSMA/CD (Carrier Sense Multiple Access/Collision Detection) 이더넷의 통신 방식 이더넷 환경에서 통신을 하고 싶을 때, Carrier Sense를 수행함 복수개의 디바이스가 동시에 통신을 시작할 때, Collision이 발생하고 이를 Detection 할 수 있음 Collision Detection이 일어난 후, 랜덤한 시간을 기다리고 다시 데이터를 보냄 데이터 링크 계층 장비브리지(Bridge) 랜(LAN)과 랜(LAN)을 연결하는 초기의 네트워크 장치 데이터 링크 계층에서 통신 선로를 따라서 한 네트워크에서 그 다음 네트워크로 데이터 프레임을 복사하는 역할 스위치 기본적으로 데이터 링크 계층에서 작동하는 스위치를 뜻함 (L2 스위치) 허브의 단점이 Collision Domain의 확대를 해결 L2 스위치는 연결된 시스템이 늘어날수록 패킷 간 충돌 때문에 매우 낮은 속도로 동작하는 더미 허브의 문제점을 해결하는 획기적인 방안 과거에는 브릿지를 통해서 Collision Domain을 나누었지만, 현재는 스위치가 인기가 많음. 스위치의 MAC 주소 테이블 시스템 간의 원활한 통신을 위해 주소 테이블을 생성하고 관리하는 역할 네트워크 계층 구조: 네트워크 계층3계층: 네트워크 계층(Network Layer) 랜(LAN)을 벗어난 통신을 하기 위해 네트워크 계층에서 IP 주소를 사용 라우팅 프로토콜을 사용하여 최적의 경로를 선택 네트워크 계층은 데이터를 패킷 단위로 분할하여 전송한 후 재결합함","link":"/2021/09/06/dataNetwork-W1/"},{"title":"[강의정리] 고급 컴퓨터수학 W1","text":"선형 대수 (Linear Algebra)스칼라 : 숫자(Magnitude)나 크기만 있고 방향을 갖지 않는 (키, 몸무게, 속력 등)벡터 : 스칼라의 배열, 크기와 방향을 가진 값 (속도 등) 공간벡터, 위치벡터..행렬 : 2차원의 배열텐서 : 임의의 차원을 갖는 배열, 좌표 변환 등으로 사용 0차 텐서, 1차 텐서, 2차 텐서, 3차 텐서 등 *","link":"/2021/09/15/AdvancedComputerMath-W1/"},{"title":"[강의정리] 알고리즘 W2","text":"Introduction to Algorithm알고리즘의 학습목표Design(설계) 알고리즘 설계하는 기법 Analysis(분석) 알고리즘을 분석, 시간/공간 복잡도 구하기 Computational Complexity(계산복잡도) 문제를 분석하여 계산적 복잡도 구하기 알고리즘의 분석시간복잡도(Time Complexity) 분석 입력 크기에 따라서 단위연산이 몇번 수행되는지 결정하는 절차(n) 표현 척도입력크기(input size) 배열의 크기, 리스트의 길이, 행렬에서 행과 열의 크기, 트리에서 마디와 이음선의 수, 그래프에서는 정점과 간선의 수단위연산(basic operation) 비교(comparison), 지정(assignment) 등 시간복잡도에 가장 크게 영향을 미치는 연산 분석 방법의 종류 모든경우 분석(Every-case analysis) 최악의 경우 분석(Worst-case analysis) 평균의 경우 분석(Average-case analysis) 최선의 경우 분석(Best-case analysis) 계산복잡도Big O 표기법정의 : 점근적 상한(Asymptotic Upper Bound)차수의 주요 성질복잡도 함수 순서 lgn, n, nlgn, n2, nj, nk, an, bnn, n!k &gt; j &gt; 2, b &gt; a &gt; 1","link":"/2021/09/15/algorithm-w2/"},{"title":"[강의정리] 알고리즘 W3 - Data Structures","text":"Data Structure ListLinked List 배열과 달리 크기를 바꿀 수 있는 자료구조 각 노드는 다음노드를 가르키는 포인터를 가짐 첫번째노드: 헤드(Head), 마지막 노드: 테일(Tail) Double Linked List 각 노드는 다음노드와 이전노드를 가르키는 포인터를 가짐 Circle Linked List Head가 Tail을 물고있는 형태의 Linked List Stack 먼저 들어간 요소가 나중에 나옴 (First-In, Last-Out: LIFO) Queue 먼저 들어간 요소가 먼저 나옴 (First-In, First-Out: FIFO) Circle QueueLinked QueueTree 나무를 닮은 구조 Root, Branch, Leaf로 이루어져 있음깊이(Depth): 루트노드에서 해당 노드까지의 경로의 길이레벨(Level): 같은 깊이를 가지는 노드의 집합높이(Height): “가장 깊은 곳”에 있는 잎노드까지의 깊이 차수(Degree): 자식 노드의 개수트리의 차수: 트리 내에 있는 노드들 가운데 자식 노드가 가장 많은 노드의 차수이진트리(Binary Tree) 모든 노드가 최대 “2 개”의 자식을 가질 수 있는 트리포화 이진 트리(Full Binary Tree) 모든 노드가 대대손손이 자식을 둘씩 가지고 있는 이진 트리완전 이진 트리 잎 노드들이 트리의 왼쪽부터 차곡차곡 채워진 트리완전 높이 균형 트리(Completely Height Balanced Tree) 루트 노드를 기준으로 왼ㅉ고 하위 트리와 오른ㅉ고 하위 트리의 높이가 같은 이진트리 Priority Queue 우선순위 속성을 갖는 데이터를 다룸 Heap 힙 순서 속성(Heap Order Property)를 만족하는 완전 이진 트리 힙 순서 속성 : 트리 내의 모든 노드가 부모 노드보다 커야 한다는 규칙 Graph인접 행렬 : 정점 끼리의 인접 관계를 나타내는 행렬","link":"/2021/10/07/algorithm-w3/"},{"title":"[강의정리] 알고리즘 week4 (merge sort)","text":"Divide-and-Conquer 분할정복식 설계전략 분할(Divide): 해결하기 쉽도록 문제를 여러 개의 작은 부분으로 나눔 정복(Conquer): 나눈 작은 문제를 각각 해결 통합(Convbine): 해결된 해답을 모음 이러한방식을 Top-Down(하향식) 접근 방법이라고 한다 Binary Search(이분검색): 재귀 알고리즘 분할: 배열을 반으로 나누어서 x가 중앙에 위치한 항목보다 작으면 왼쪽에 위치한 배열 반쪽을 선택, 그렇지 않으면 오른쪽에 위치한 배열 반쪽을 선택 정복: 선택된 반쪽 배열에서 X를 찾는다 통합: 필요없음 재귀 알고리즘(recursive algorithm)에서 모든 재귀호출이 알고리즘의 마지막(꼬리) 부분에서 이루어 질 때 꼬리 재귀호출(tail recursion)이라고 함 - 그 알고리즘은 반복 알고리즘(iterative algorithm)으로 변환하기 수월ㅋ 최악의 경우 시간복잡도 분석 단위연산: x와 S[mid]의 비교 입력 크기: 배열의 크기 n(= high - low + 1) 알고리즘에서는 단위연산으로 설정한 조건문을 while루프 내에서 2번 수행하지만, 사실상 비교는 한번만 수행(1) 어셈블리언어로는 하나의 조건 명령으로 충분히 구현 가능(2) x를 찾기 전까지는 항상 2개의 조건문을 수행하므로 하나로 묶어서 한 단위로 취급해도 됨 경우 1: 검색하게 될 반쪽 배열의 크기가 항상 정확하게 n/2이 되는 경우 시간복잡도를 나타내주는 재현식(recurrence)는 다음과 같다W(n) = W(n/2)+1, n &gt; 1이고, n = 2k(k&gt;=1)W(1) = 1이식의 해는 다음과 같이 구할 수 있다W(1) = 1W(2) = W(1) + 1 = 2W(4) = w(2) + 1 = 3W(8) = W(4) + 1 = 4W(16) = W(8) + 1 = 5…W(2k)=k+1…W(n) = lg n + 1 증명: 수학접 귀납법:귀납 출발점: n=1이면, W(1) = 1 = lg 1 + 1.귀납 가정: 2의 거듭제곱(power)인 양의 정수 n에 대해서, W(n)=lg n + 1라고 가정귀납 단계: W(2n) = lg(2n) + 1임을 보이면 된다. 재현식을 사용하면,W(2n) = W(n) + 1 = lg n + 1 + 1 = lg n + lg 2 + 1 = lg(2n) + 1 경우 2: 일반적인 경우 - 반쪽 배열의 크기는 [n/2]이 됨합병정렬(Mergesort)123456789101112void mergesort (int n, keytype S[]) { const int h = n / 2, m = n - h; keytype U[1..h], V[1..m]; if(n&gt;1) { copy S[1] through S[h] to U[1] through U[h]; copy S[h+1] through S[n] to V[1] through V[m]; mergesort(h,U); mergesort(m,V); merge(h,m,U,V,S); }} 시간복잡도 분석합병 알고리즘의 최악의 경우 시간복잡도 분석 단위연산: U[i]와 V[j]의 비교 입력크기: 2개의 입력 배열에 각각 들어있는 항목의 개수: h와 m 분석: i=h이고, j=m-1인 상태로 루프(loop)에서 빠져 나가는 때가 최악의 경우로서 (V에 있는 처음 m-1개의 항목이 S의 앞부분에 위치하고, U에 있는 h개의 모든 항목이 그 뒤에 위치하는 경우), 이때 단위연산의 실행 횟수는 h + m - 1이다. 따라서 최악의 경우 합병하는 시간복잡도는 W(h, m) = h + m - 1. 합병정렬 알고리즘의 최악의 경우 시간복잡도 분석 단위연산: 합병 알고리즘 merge에서 발생하는 비교 입력크기: 배열 S에 들어 있는 항목의 개수 n 분석: 최악의 경우 수행시간은 W(h,m) = W(h) + W(m) + h + m - 1이 된다. 여기서 W(h)는 U를 정렬하는데 걸리는 시간, W(m)은 V를 정렬하는데 걸리는 시간, 그리고 h + m - 1은 합병하는데 걸리는 시간이다. 정수 n을 2k(k&gt;=1)이라고 가정하면, h= n/2, m=n/2가 된다. 따라서 최악의 경우 재현식은:W(n) = 2W(n/2)+n-1 n&gt;1이고, n=2k(k&gt;=1)W(1) = 0 왜냐하면 합병이 전혀 이루어지지 않으므로 이 재현식의 해는 아래의 도사정리의 2번을 적용하면W(n) = O(n lg n)이 된다.","link":"/2021/10/08/algorithm-w4/"},{"title":"[강의정리] 알고리즘 W5 (quicksort, sorting algo)","text":"Quicksort 분할교환정렬(patition exchange sort)라고 불린다.12345678910111213141516171819202122void quicksort(index low, index high) { index pivotpoint; if (high &gt; low) { partition(low, high, pivotpoint); quicksort(low, pivotpoint-1); quicksort(pivotpoint+1, high); }}void partition(index low, index high, index&amp; pivotpoint) { index i, j; keytype pivotitem; pivotitem = S[low]; //pivotitem을 위한 첫번째 항목을 고른다. j = low; for(i = low + 1; i &lt;= high; i++) if(S[i] &lt; pivotitem) { j++; exchange S[i] and S[j]; } pivotpoint = j; exchange S[low] and S[pivotpoint]; //pivotitem값을 pivotpoint에 넣는다} 분석 단위연산: S[i]와 key와의 비교 입력크기: 부분배열이 가지고 있는 항목의 수, n = high - low + 1 분석: 배열의 첫번째 항목만 제외하고 모든 항목을 한번씩 비교하므로, T(n) = n - 1이다. 최악의 경우 시간복잡도 분석 단위연산: 분할 알고리즘의 S[i]와 pivotitem과의 비교 입력크기: 배열 S가 가지고 있는 항목의 수, n 분석: 이미 비내림차순으로 정렬이 되어있는 배열을 정렬하려는 경우가 최악의 경우가 됨. 비내림차순이면 첫번째(pivot)항목보다 작은 항목은 없으므로, 크기가 n인 배열은 크기가 0인 부분은 왼쪽에 오고, 크기가 n-1인 부분배열은 오른쪽에 오도록 하여 계속 쪼개진다. 따라서, T(n) = T(0) + T(n-1) - n - 1 그런데 T(0) = 0이므로 재현식은 다음과 같이 된다. T(n) = T(n-1) + n - 1, n &gt; 0이면 T(0) = 0 이 재현식을 풀면, T(n) = T(n-1) + n - 1 T(n-1) = T(n-2) + n - 2 T(n-2) = T(n-3) + n - 3 ... T(2) = T(1) + 1 T(1) = T(0) + 0 T(0) = 0 T(n) = 1 + 2 + ... + (n-1) = n(n-1) / 2 평균의 경우를 고려한 시간복잡도 분석 단위연산: 분할알고리즘의 S[i]와 pivotitem과의 비교 입력크기: 배열이 S가 가지고 있는 항목의 수, n 분석:","link":"/2021/10/10/algorithm-w5/"},{"title":"[강의정리] 고급 컴퓨터수학 W6-대면(화)","text":"Loss Function, Cost Function 모델의 예측값과 실제 값의 오차 Example of Loss FunctionMean Squared Error: 에러의 제곱 이용 계산 간편 크기에 의존적 Cross Entropy: 확률의 불확실성 수치 실제 분포를 모를때 예측가능 0일수록 출력이 확실함","link":"/2021/10/12/advCmpMath-W6-meet/"},{"title":"[강의정리] 알고리즘 W6 (Dynamic Programming)","text":"Dynamic programming Similar to divide-and-conquer small instances first, store the results, whenever we need a result, look it up instead of recomputing it. 알고리즘: Using Divide-and-Conquer 문제: 이항계수를 계산한다 입력: 음수가 아닌 정수 n과 k, 여기서 k &lt;= n 출력: bin, [n k] 123456int bin(int n, int k) { if (k == 0 || n == k) return 1; else return bin(n-1, k-1) + bin(n-1, k);} 시간복잡도 분석: 분할정복 알고리즘은 작성하기는 간단하지만, 효율적이지 않음 이유? 재귀호출(recursive call)할때 같은 계산을 반복해서 수행하기 때문 예를 들면, bin(n-1, k-1)과 bin(n-1, k)는 둘다 bin(n-2, k-1)의 결과가 필요한데, 따로 중복 계산이 됨 [n: k]를 구하기 위해서 이 알고리즘이 계산하는 항(term)의 개수는 2[n: k]-1이다. (증명을 해보자) 증명: (n에 대한 수학적 귀납법으로 증명) 귀납출발점: 항의 개수 n이 1일 때 2[n: k]-1 = 2 x 1 - 1 = 1이 됨을 보이면 된다. [1: k]는 k=0이나 1일때 1이므로 항의 개수는 항상 1이다. 귀납가정: [n: k]를 계산하기 위한 항의 개수는 2[n: k] - 1이라고 가정한다. 귀납절차: [n+1: k]를 계산하기 위한 항의 개수가 2[n+1: k] - 1임을 보이면 된다. 알고리즘에 의해서 [n+1: k] = [n: k-1] + [n: k] 이므로, [n+1: k]를 계산하기 위한 항의 총 개수는 [n: k-1]을 계산하기 위한 총 개수와 [n: k]를 계산하기 위한 항의 총 개수에다가 이 둘을 더하기 위한 항 1을 더한 수가 된다. 그런데 [n: k-1]을 계산하기 위한 항의 개수는 가정에 의해서 2[n: k-1] -1이고, [n: k]를 계산하기 위한 항의 개수는 가정에 의해서 2[n: k] - 1이다. 동적계획식 알고리즘 설계전략 Establish a recursive property (재귀 관계식을 정립): 2차원 배열 B를 만들고, 각 B[i][j]에는 [i: j]값을 저장하도록 하면, 그 값은 다음과 같은 관계식으로 계산할 수 있다. Solve an instance of the problem in a bottom-up fashion: [n: k]를 구하기 위해서는 다음과 같이 B[0][0]부터 시작하여 위에서 아래로 재귀 관계식을 적용하여 배열을 채워 나가면 된다. 결국 값은 B[n][k]에 저장된다. 문제: 이항계수를 계산한다. 입력: 음수가 아닌 정수 n 과 k, 여기서 k &lt;= n 출력: bin, [n: k] 123456789int bin2(int n, int k) { index i, j; int B[0..n][0..k]; for(i = 0; i &lt;= n; i++) for(j = 0; j &lt;= minimum(i,k); j++) if(j==0 || j==1) B[i][j] = 1; else B[i][j] = B[i-1][j-1] + B[i-1][j]; return B[n][k];} 동적계획 알고리즘의 분석 단위연산: for-j 루프 안의 문장 입력의 크기: n, ki = 0일 때 j-루프 수행 횟수 : 1i = 1일 때 j-루프 수행 횟수 : 2i = 2일 때 j-루프 수행 횟수 : 3……………i = k-1일 때 j-루프 수행 횟수 : ki = k일 때 j-루프 수행 횟수 : k + 1i = k+1일 때 j-루프 수행 횟수 : k + 1……………i = n일 때 j-루프 수행 횟수 : k + 1 따라서 총 수행횟수는:1 + 2 + 3 + … + k + (k+1) + … + (k+1) = k(k+1)/2 + (n-k+1)(k+1) = (2n-k+2)(k+1)/2 = O(nk) 그래프그래프 용어 정점(vertex, node), 이음선(edge, arc) 방향 그래프(directed graph, or digraph) 가중치(weight), 가중치 포함 그래프 (weighted graph) 경로(path) - 두 정점사이에 edge가 있는 정점들의 나열 단순경로(simple path) - 같은 정점을 두 번 지나지 않음 순환(cycle) - 한 정점에서 다시 그 정점으로 돌아오는 경로 순환그래프(cyclic graph) vs 비순환 그래프 (acyclic graph) 길이(length): the sum of weights on the path (weighted graph) the number of edges on the path (unweighted graph) Shortest Path Shortest Path: 한 도시에서 다른 도시로 직항로가 없는 경우 가장 빨리 갈 수 있는 항로를 찾는 문제 문제: 가중치 포함, 방향성 그래프에서 최단경로 찾기 Optimization problem (최적화 문제)의 정의 주어진 문제에 대하여 하나 이상의 많은 해답 후보가 존재할 때, 이와 연관된 값이 최소 또는 최대인 해답(optimal solution)을 찾아야 하는 문제 에너지 최소화 문제라고도 함. shortest Path는 Optimization problem에 속함 Brute-force algorithm(무작정 알고리즘) 한 정점에서 다른 정점으로의 모든 경로의 길이를 구한 뒤, 그들 중에서 최소길이를 찾는다. 동적계획식 설계전략 - 자료구조 그래프의 인접행렬(adjacent matrix)식 표현: W 동적계획식 설계절차 Establish a recursive property D(k-1)을 가지고 D(k)를 계산할 수 있는 재귀 관계식을 정립 D(k)[i][j] = minimum(D(k-1)[i][j], D(k-1)[i][k] + D(k-1)[k][j]) 경우 1: {v1, v2,…, vk}의 정점들 만을 통해서 vi에서 vj로 가는 최단 경로가 vk를 거치지 않는 경우, 보기: D(5)[1][3] = D(4)[1][3] = 3 경우 2: {v1, v2,…, vk}의 정점들 만을 통해서 vi에서 vj로 가는 최단 경로가 vk를 거치는 경우, 보기: D(2)[5][3] = D(1)[5][2] + D(1)[2][3] = 4 + 3 = 7 보기: D(2)[5][4] 상향식으로 k=1부터 n까지 다음과 같이 이 과정을 반복하여 해를 구한다.D(0), D(1),……,D(n) Floyd’s Algorithm I 가중치 포함 그래프의 각 정점에서 다른 모든 정점까지의 최단거리를 계산 12345678void floyd(int n, const number W[][], number D[][]) { int i, j, k; D = W; for(k=1; k &lt;= n; k++) for(i=1; i &lt;= n; i++) for(j=1; j &lt;= n; j++) D[i][j] = minimum(D[i][j], D[i][k]+D[k][j]);} Floyd’s Algorithm II 가중치 포함 그래프의 각 정점에서 다른 모든 정점까지의 최단거리를 계산, 각각의 최단경로를 구하라. 1234567891011121314void floyd2(int n, const number W[][], number D[][], index P[][]) { index i, j, k; for(i=1; i &lt;= n; i++) for(j=1; j &lt;= n; j++) P[i][j] = 0; D = W; for(k=1; k &lt;= n; k++) for(i=1; i &lt;= n; i++) for(j=1; j &lt;= n; j++) if(D[i][k] + D[k][j] &lt; D[i][j]) { P[i][j] = k; D[i][j] = D[i][k] + D[k][j]; }} 최단경로의 출력1234567void path(index q,r) { if(P[q][r] != 0) { path(q, P[q][r]); count &lt;&lt; &quot;v&quot; &lt;&lt; P[q][r]; path(P[q][r], r); }} 최적의 원칙 어떤문제의 입력에 대한 최적해가 그 입력을 나누어 쪼갠 여러 부분에 대한 최적 해를 항상 포함하고 있으면 그 문제는 최적의 원칙(the principle of optimality)이 적용된다 라고 한다. Optimal Binary Search Trees definition binary search tree Ordered set Each node contain one key The keys in the left subtree are less than or equal to the key in that tree Depth - number of edges from the root balanced - if the depth of the 2 subtrees of every node never different by more than 1 optimal - the average time it takes to locate a key is minimized 123456789101112131415void optsearchtree(int n, const float p[], float&amp; minavg, index R[][]) { index i, j, k, diagonal; float A[1...n+1][0..n]; for(i=1; i&lt;=n; i++) { A[i][i-1] = 0; A[i][i] = p[i]; R[i][i] = i; R[i][i-1] = 0; A[n+1][n] = 0; R[n+1][n] = 0; for(diagonal=1; diagonal &lt;= n-1; diagonal++) for(i=1; i&lt;=n-diagonal; i++) { j = i + diagonal; A[i][j] = minimum(A[i][k-1] + A[k+1][j]) + R[i][j] = a value of k that gave the minimum; } minavg = A[1][n]; }} The Traveling Salesperson Problem Problem Definition Determine a shortest route that starts at the salesperson’s home city, visits each of the cities once, and ends up at the home city Adjacent matrix W V = set of all the vertices A = a subset of V D[vi][A] = length of a shortest path from vi to v1 passing through each vertex in A exactly once Length of an optimal tour = minimum(W[1][j] + D[vj][V - {v1, vj}]) ```Cvoid travel(int n, const number W[][], index P[][], number&amp; minlength) { index i, j, k; number D[1..n][subset of V-{v1}]; for(i=2; i&lt;=n; i++) D[i][0] = W[i][1]; for(k=1; k&lt;=n-2; k++) for(all subsets A V-{v1} containing k vertices) for(i such that i!= 1 and vi is not in A) { D[i][A] = min(j:vj A)(W[i][j]+D[j][A-{vj}]); P[i][A] = value of j that gave the minimum; } D[1][V-{v1}] = min(2&lt;=j&lt;=n)(W[1][j] + D[j][A-{v1,vj}]); P[1][V-{v1}] = value of j that gave the minimum; minlength = D[1][V-{v1}]}","link":"/2021/10/17/algorithm-w6/"},{"title":"[강의정리] 생명정보 week7 대면정리","text":"조원: 허주미, 홍지윤발표 주제 선택","link":"/2021/10/14/infoScience-W7-meet/"},{"title":"[강의정리] 데이터통신과네트워크 Computer Network and the Internet","text":"What’s the Internet“nuts and bolts” view billions of connected computing devices: hosts = end systems running networks apps communication links fiber, copper, radio, stellite transmission rate: bandwidth packet switches: forward packets (chunks of data) routers and switches Internet: “network of networks”protocols control sending, receiving of message e.g., TCP, IP, HTTP, … Internet standards Internet Engineering Task Force (IETF) 에서 Request for comment (RFC)라는 표준 문서들을 개발함 A service viewinfrasturcture that provides services to applications: Web, VoIP, email, games, e-commerce, social nets, … Socket interface allows sending and receiving app programs to “connect” to Internet provides service options, analogous to postal service What’s a protocol?network protocols: machine rather than humans three way handshaking protocols define format, order of messages sent and received among network entities, and actions taken on message transmission, receipt Network edgeA closer look at network structrueNetwork edge (종단 시스템) hosts: clients and servers Access networks Home, Enterprise, Mobile, …Physical media wired, wireless communication links Access networks and pysical mediaHow to connect end systems to end router? residential(Home) access networks institutional access networks mobile access networks keep in mind: bandwidth (bits per second) of access network? (속도) shared or dedicated? (나만쓰는가?) Home AccessHome Access: DSLDigital Subscriber Line (DSL) 전화선을 이용한 통신 Home Access: Cable Internet AccessHFC: hybrid fiber coax (동축 케이블)Coaxial and fiber cables attach homes to ISP router fiber와 Coaxial 동시에 사용 Home Access: FTTHFiber to the home fiber만 사용 Home Access: A typical home network Enterprise accessEnterprise access: EthernetPhysical mediaPhysical media: Twisted-Pair Copper Wire Unshielded twisted pair (UTP) Shielded twisted pair (STP) Pysical media: Radio no physical “wire” Network core Mesh of interconnected routers Packet-switching Message는 application이 원하는 데이터를 포함 Message를 잘게 쪼갠게 packets Packet들이 Communication link로 이동할때 transmission rate기반으로 이동 패킷의 크기는 L bits, 전송 속도는 R bits/sec Packet-switching: Store-and-Forward 저장하고 전달 Ex) L = 7.5 Mbits, R = 1.5 Mbps, one-hop transmisson delay = 5 s End to End Delay = 2L/R 3개의 패킷을 보내는 시간 L/R시간, 첫번째 패킷이 라우터에 도착 2L/R시간, 첫번째 패킷이 목적지 도착, 두번째 패킷 라우터 도착 3L/R시간, 두번째 패킷이 목적지 도착, 세번째 패킷 라우터 도착 4L/R시간, 세번째 패킷이 목적지 도착 하나의 패킷을 N개의 링크가 있는 곳으로 보내는 End to End 딜레이 (N links (eash of rate R), N-1 Routers) Dend-to-end = N X (L/R) Queuing Delays and Packet LossQueuing and Loss: 도착하는 패킷보다 보내는 패킷이 느릴경우 딜레이 + 공간 꽉차면 Loss까지 생김 Forwarding and Routing Forwarding: input에서 output으로 움직이는것 Routing: 어디로 갈지 정해주는것 Circuit switching 데이터 회선이 정해지고 회선단위로 데이터를 주고받음 frequency-division multiplexing (FDM) - 주파수분할time-division multiplexing (FDM) - 시분할 Silend Period -&gt; 네트워크 자원낭비로 이어짐 Packet Switching vs. Circuit switching Packet switching allows more user to use network 1 Mb/s link each user: 100 kb/s when “active” the probability that a specific user is active is 0.1 circuit switching: support only simultaneous 10 users (1 Mbs/ 100 Kbps) Packet switching: With 35 users, probability &gt; 10 active at same time is less than 0.0004 35C11(0.9)24(0.1)11 &lt; 0.0004 Packet switching이 좋지만, packet delay나 loss가 발생할 수 있음 reliable한 데이터 전송이 필요 Network of networks End systems은 access ISPs (Internet Service Providers) Delay, Loss, Throughput in NetworksFour sources of packet delay Total nodal delay (dnodal) nodal processing delay (dproc), queuing delay (dqueue), transmission delay (dtrans), propagation delay (dprop) dproc: nodal processing check bit errors determine output link typically &lt; msec dqueue: queueing delay 라우터 개수에 의존 가장 중요 dtrans: transmission delay L: packet length (bits) R: link bandwidth (bps) dtrans = L/R dprop: propagation delay d: length of physical link s: propagation speed (통신매체에 따라 다름) dprop = d/s Transmission delay vs. Propagation delayCaravan analogy cars “propagate” at 100 km/hr toll booth takes 12sec to service car (bit transmission time) 2번째 톨게이트까지 가는 시간? 첫번째 톨게이트 12*10 = 120s 100km 가는 시간 = 1hr A: 62 min Queueing delay R: link bandwidth (bits / sec) L: packet length (bits) a: average packet arrival rate (packets/sec) La/R: traffic intersity La/R이 0에 가까우면: 딜레이가 거의 없음 La/R이 1에 가까우면: queueing delay가 커짐 La/R이 1보다 크면: 거의 무한대의 딜레이 Packet loss 버퍼가 가득 차면 loss 됨 End-to-End Delay N-1개의 라우터가 있을때 End-to-End Delay = N x (dproc+dtrans+dprop) Throughtput(처리량) Networks under attack: SecurityNetwork security","link":"/2021/10/20/dataNetwork-Chapter1/"},{"title":"[연습문제] 데이터통신과네트워크 Computer Network and the Internet","text":"2020-1:Host A 와 Host B 가 30,000 km 떨어진 곳에 위치하고 있고 R=5Mbps 의 속도의 네트워크 링크로연결되어져 있다 해당 네트워크의 propagation delay 는 𝟐.𝟓×𝟏𝟎^𝟖 meters/sec 이다Host A 에서 Host B 로 1,000,000 bits 의 파일을 분할없이 한번에 보낸다고 가정했을 경우 파일을보내는 시간동안 네트워크 링크에 존재하는 최대 비트 수는 얼마인가(네트워크 링크는 H ost A 와 Host B 만 사용하는 링크임 , Mega = 10^6) transmission delay: 0.2sprop delay: 0.12s600,000 bits 2020-2:네트워크를 통해 사이즈가 큰 데이터를 보낼 때 일반적으로 해당 데이터를 작은 사이즈의패킷으로 쪼갠 후 보내게 된다 해당 패킷들을 받는 수신자는 수신한 패킷들을 재조합 하여데이터 원본을 수신한다 이러한 과정을 message segmentation 이라고 부르기도 한다아래 그림은 message segmentation 이 없는 데이터 전송과 message segmentation 이 적용된데이터 전송을 나타내고 있다 Source 에서 Destination 사이에는 스위치가 2 개가 존재하고 ,Source 가 Destination 으로 보내려는 데이터 의 크기는 𝟏.𝟐×𝟏𝟎^𝟖 bits 이다 네트워크 링크 전송속도는 R=4Mbps 일 때 아래 물음에 답하시오 propagation, queuing, and processing delays 는무시한다 1 - Message segmentation 이 없는 데이터 전송 (위 그림의 (a)) 를 고려했을 때 Source 에서 Destination 까지 전체 데이터를 보내는데 걸리는 시간은 얼마인가? 3*L/R = 3 * 1.2 * 10^8 / 4 * 10^6 = 3 * (1.2 * 10^2 / 4) = 3 * 0.3 * 10^2 = 3 * 30 = 90s 2 - 전체 데이터가 1200 개의 패킷으로 나누어지고 각 패킷의 길이는 100,000bit 라고 가정해보자 Message segmentation 가 적용된 데이터 전송 (위 그림 의 (b)) 를 고려했을 때 Source 에서 Destination 까지 첫번째 패킷을 보내는데 걸리는 시간은 얼마인가? 100,000 / 5,000,000 = 1/50 = 0.02s, 0.02s * 3 = 0.06s 3 - 전체 데이터가 1200 개의 패킷으로 나누어지고 각 패킷의 길이는 100,000bit 라고 가정해보자 Message segmentation 가 적용된 데이터 전송 (위 그림 의 (b)) 를 고려했을 때 Source 에서 Destination 까지 전체 패킷 총 1200 개의 패킷 을 보내는데 걸리는 시간은 얼마인가? 하나의 패킷이 걸리는 시간 0.6s, 하나의 구간을 통과하는 시간 0.2s, 3개를 동시에 하므로 1200 * 0.2s = 240s - 0.4s = 239.6s 4 - message segmentation 장단점 장점: message를 나눠서 보내면 중간에 라우터에서도 동시에 전송을 할 수 있어서 시간이 짧아짐 단점: 패킷이 중간에 없어질 수 도있음","link":"/2021/10/21/dataNetwork-Chapter1Q/"},{"title":"[강의정리] 데이터통신과네트워크 Application Layer","text":"Principles of network applicationsApplication architectures client-server peer-to-peer Client-server architecture server: always-on host permanent IP address clients: communicate with server may be intermittently connected do not communicate directly P2P architecture No always-on server Processes communicating Process: program running within a host 같은 host 에서, inter-process communication을 통하여 두개의 프로세스가 통신 Sockets Process sends/receives messages to/from its socket Socket analogous to door Addressing processes Identifier includes both IP address and port numbers associated with process on host. Example port numbers: HTTP server: 80 mail server: 25 to send HTTP message to usaint web server: IP address: 203.253.31.114 port number: 80 App-layer protocol defines Types of messages exchanged, E.g., request, response Message syntax 구역 나누기","link":"/2021/10/21/dataNetwork-Chapter2/"},{"title":"[강의정리] 데이터통신과네트워크 Transport Layer","text":"Transport-layer servicesTransport vs. Network layer Network: hosts 사이 Transport: processes 사이 Internet transport-layer protocols Reliable in-order delivery -&gt; Transmission Control Protocol(TCP) Unrealiable, unordered delivery -&gt; User Datagram Protocol (UDP)","link":"/2021/10/21/dataNetwork-Chapter3/"},{"title":"algorithm-w8","text":"","link":"/2021/11/18/algorithm-w8/"},{"title":"dataNetwork-transport","text":"","link":"/2021/11/26/dataNetwork-transport/"}],"tags":[{"name":"summary","slug":"summary","link":"/tags/summary/"},{"name":"Div.3","slug":"Div-3","link":"/tags/Div-3/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Problem Solve","slug":"Problem-Solve","link":"/tags/Problem-Solve/"},{"name":"Div.2","slug":"Div-2","link":"/tags/Div-2/"},{"name":"Computer Network","slug":"Computer-Network","link":"/tags/Computer-Network/"},{"name":"Computer Math","slug":"Computer-Math","link":"/tags/Computer-Math/"},{"name":"Information Science","slug":"Information-Science","link":"/tags/Information-Science/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Codeforces","slug":"Algorithm/Codeforces","link":"/categories/Algorithm/Codeforces/"},{"name":"Lecture Summary","slug":"Lecture-Summary","link":"/categories/Lecture-Summary/"},{"name":"Problems","slug":"Algorithm/Codeforces/Problems","link":"/categories/Algorithm/Codeforces/Problems/"},{"name":"Computer Data Network","slug":"Lecture-Summary/Computer-Data-Network","link":"/categories/Lecture-Summary/Computer-Data-Network/"},{"name":"Information Science","slug":"Lecture-Summary/Information-Science","link":"/categories/Lecture-Summary/Information-Science/"},{"name":"Advanced Computer Math","slug":"Lecture-Summary/Advanced-Computer-Math","link":"/categories/Lecture-Summary/Advanced-Computer-Math/"},{"name":"Algorithm","slug":"Lecture-Summary/Algorithm","link":"/categories/Lecture-Summary/Algorithm/"}]}