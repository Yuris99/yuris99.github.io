{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Codeforces Round #739 (Div. 3) 리뷰","text":"알고리즘 공부를 열심히 하겠다고 마음먹은뒤 결국 Div. 2 하나를 놓치고 지나갔다.결국 바로 다음에 있는 Div. 3부터 치르게 되었는데, 오랜만이라 그런가 생각보다 쉽지 않았다.앞으로 알고리즘 공부한것들의 리뷰를 해볼생각이다. 실력이 조금이라도 늘겠지… Result # A B C D E F1 F2 Attr 1 3 1 0 - - - Attr* - - - 1 - - - Time 20 55 15 Over - - - Solve O O O Late - - - Adjustment Rating Ranking Tear 1023 (+49) 10341 (+3079) Newbie","link":"/2021/08/19/codeforces-739/"},{"title":"Codeforces Round #739 (Div. 3) Problem. A","text":"https://codeforces.com/contest/1560/problem/ACodeforces Round #739 (Div. 3) A. Dislike of Threes TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 implementation Attr SubNo SolveTime Time Memory Accept? 1 126297598 20min 31 ms 3660KB Accepted 문제 요약Polycarp은 3을 싫어한다. 3으로 끝나는 문자와 3으로 나누어 떨어지는 문자를 제외하고 숫자를 세어서 n번째 숫자를 구해라 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= k &lt;= 1000) Output각 Testcase 마다1개의 정수 x : Polycarp이 싫어하지 않는 k-th 숫자 문제 풀이정말 간단하게 풀 수 있다. 단순한 1차원 반복문을 사용하여 num이 3으로 나누어떨어지거나 3으로 끝나면(10으로 나누었을때 나머지가 3이면) 한번 더 더해서 카운트를 건너뛰어주었다. 최종 코드123456789101112131415161718192021#include &lt;iostream&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int k; cin &gt;&gt; k; int num = 0; for(int i = 1; i &lt;= k; i++) { num++; while(num % 3 == 0 || num % 10 == 3) num++; } cout &lt;&lt; num &lt;&lt; endl; } return 0;} 느낀점800점대 문제면서 Div. 3 A번 문제라 정말 쉬웠다. 간단한 루프문으로 해결될줄은 몰랐지만 생각보다 빠르게 끝냈다.","link":"/2021/08/21/codeforces-739-A/"},{"title":"Codeforces Round #739 (Div. 3) Problem. B","text":"https://codeforces.com/contest/1560/problem/BCodeforces Round #739 (Div. 3) B. Who’s Opposite? TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 math Attr SubNo SolveTime Time Memory Accept? 1 126327661 +40min 1000 ms 3700KB Time limit 2 126332184 +8min (48m) 77 ms 3600KB Wrong answer 3 126336434 +8min (56m) 93 ms 3700KB Accepted 문제 요약원형의 식탁에서 회의를 하는데 인원은 모르고(짝수이다) 모든 사람은 서로 마주보는 상대가 있다.각자의 번호는 1부터 시작해서 시계방향으로 숫자를 매긴다.a 와 b가 마주보고 있을 때, c와 마주보고 있는 사람의 번호를 구하여라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 104)각 Testcase 마다t-th line : space로 구분된 3개의 정수 (1 &lt;= a, b, c &lt;= 108) Output각 Testcase 마다1개의 정수 d : c와 마주보고있는 숫자답이 여러개일시 아무거나 출력, 답이 없으면 -1출력 문제 풀이이문제 또한 어려운 문제는 아니였다. 규칙만 잘 찾으면 되는 문제였지만, 예상외로 해맸었다. Attr 1 (Time Limit exceeded on test 2)첫시도부터 굉장히 복잡하게 생각을 했는데 일단 무조건 규칙이 있을것이라고 예상을 하였다. 그래서 열심히 규칙을 찾아본 결과..서로 마주보는 a와 b를 기준으로 a-n은 b-n을 마주보고 있다는 사실을 알게 되었다.또한 계속 빼가다가 어느 한 수가 0에 도달하게 되면, 큰수 + (큰수 - n - 작은수)가 원탁에 앉아있는 총 인원 수가 나왔다. 복잡하다또는 큰수-n과 작은수의 값이 같아지면, 큰수 + (작은수 - n) 의 값이 총 인원수가 되었다. 결국 for문으로 돌려서 위 두 케이스중 하나의 케이스가 나오게 되면 Loop를 빠져나가고 남은 값들을 계산하여 값을 도출해 냈다. 물론 결과는 시간 초과최대 시간복잡도가 104X108 = 1012(약 1조…)가 나와버린다… 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); int i, meet = small - 1; int result = -1; for (i = big-1; i &gt; small &amp;&amp; meet &gt; 0; i--, meet--) { if (result == -1) { if(i == c) result = meet; else if(meet == c) result = i; } } //cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;, m = &quot; &lt;&lt; meet &lt;&lt; endl; if(result == -1 &amp;&amp; i &gt; small &amp;&amp; meet == 0) { if(c &gt; small &amp;&amp; c &lt;= i) result = big + (c-small); else if(c &gt; big &amp;&amp; c &lt;= (big + (i-small))) result = small + (c-big); } cout &lt;&lt; result &lt;&lt; endl; } return 0;} Attr 2 (Wrong answer on test 2)시간초과로 한대 맞고난 뒤 for문으로 해결할 수 없는 문제라는 사실을 문제를 본지 40분만에 알아차렸다. 결국 다른 규칙을 찾다가 한가지 핵심적인 규칙을 깨닳을 수 있었다. 서로 마주보고있는 두 수의 간격은 무조건 전체 인원수의 절반이 된다.이 규칙을 찾은 후 이 규칙을 가지고 코드를 짰다. 기본적으로 두 수의 간격을 구하고, 그 간격을 기준으로 c값이 작으면 전체 인원수의 절반을 더해주고, c값이 크면 전체 인원수의 절반을 빼주는 형식으로 정답을 구했다. 또한 몇가지의 예외사항을 넣어두었다. 앞에서 했던 for문 뻘짓을 왜했는지 이해가 되지 않았지만 8분만에 코드를 짜고 제출을 하였다.그러나 결과는 오답공식에는 문제가 없었다. 다른 예외사항이 있는듯했다. 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c, result = -1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); int dis = big - small; if(c &gt; dis) result = c-dis; else if (c &lt;= dis) result = c + dis; if(result &gt; dis*2 || big &gt; dis*2) result = -1; cout &lt;&lt; result &lt;&lt; endl; } return 0;} Attr 3 (Accepted!)결국 또하나의 예외를 찾아내고 나서야 문제를 해결할 수 있었다. “c가 전체 인원수보다 크면: a와 b가 마주보고 있는 원탁에는 c는 존재할 수 없다.”결론적으로 이 예외조건을 추가하니 정상적으로 코드가 Accept 되었다. 최종 해설서로 마주보고있는 두 수의 간격은 무조건 전체 인원수의 절반이 된다. a와 b를 사용하여 전체 인원수의 절반을 구하고, 그 수를 기준으로 하여 c에 따라서 결과값을 구해주면 된다.규칙만 잘찾으면 어렵지않게 풀 수 있는 문제였다. 괜히 반복문으로 접근해서 시간만 날렸다 ?c가 전체 인원수의 절반보다 작거나 같으면: 정답 : c + 전체 인원수의 절반; ?아니면 c가 전체 인원수의 절반보다 크면: 정답 : c - 전체 인원수의 절반; 만약: 정답이 전체 인원수보다 크면: 정답 : -1; 제대로된 원탁이 아니다. 또는: c가 전체 인원수보다 크면: 정답 : -1; a와 b가 마주보고 있는 원탁에는 c는 존재할 수 없다. 또는: a와 b중에 큰 수가 전체 인원수보다 크면: 정답 : -1; a와 b중에 큰 수는 제대로된 원탁에 존재할 수 없다. 최종 코드12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int a, b, c, result = -1; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int big = max(a, b); int small = min(a, b); //총 인원수의 절반 int dis = big - small; if(c &gt; dis) result = c-dis; else if (c &lt;= dis) result = c + dis; //답이 나오지 않는 경우 if(result &gt; dis*2 || big &gt; dis*2 || c &gt; dis*2) result = -1; cout &lt;&lt; result &lt;&lt; endl; } return 0;} 느낀점원형탁자 -&gt; 숫자 -&gt; 순서대로 -&gt; 반복문!! 일것이라고 안일하개 생각한게 문제가 되었다.결국 초반에 반복문으로 계속 고민을 하다가 시간만 날려버리게 되었다.문제를 해결하는 방법에 편견을 가지지 말고 다양한 방법을 생각해 봐야할 것 같다.","link":"/2021/08/23/codeforces-739-B/"},{"title":"Codeforces Round #739 (Div. 3) Problem. C","text":"https://codeforces.com/contest/1560/problem/CCodeforces Round #739 (Div. 3) C. Infinity Table TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 implementation math Attr SubNo SolveTime Time Memory Accept? 1 126343911 +14min (70m) 30 ms 3600KB Accepted 문제 요약2차원배열 가장 왼쪽 위부터 시작하는 table이 있다. 이table은 다음과같은 패턴으로 순서대로 생성이 된다.위와같은 패턴으로 table이 무한정 생성될 때 k가 존재하는 행과 열을 구하여라. 피드백Input1-st line : Testcase (1 &lt;= t &lt;= 100)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= k &lt;= 109) Output각 Testcase 마다2개의 정수 (r, c &gt;= 1) space로 구분 : k가 위치하고있는 열과 행 문제 풀이또 800점 문제이다. 또한 패턴만 구하면 간단하게 해결할 수 있었다. 0번째 열을 확인해보면 각각 n번째 행의 원소들이 n의 제곱인것을 확인할 수 있다.다르게 말하면 0번째 행의 0보다 큰 n번째 열의 원소는 n-1의 제곱 + 1이라는 사실도 성립된다.또한 변화하는 행과 열의 종류가 변경되는 시점은 n-1의 제곱 + (n-1)이기 때문에 k의 위치는 쉽게 구할 수 있었다. 최종 해설먼저 정수형 sq를 선언하여 k의 제곱근(소수점부분은 제외)을 구하였다. 만약 소수점을 제외한 sq의 제곱이 k와 같다면, k의 위치는 0열 sq행으로 고정되기 때문에 예외를 두어 처리를 해 주었다. 다음으로 알아야 하는것은 k가 위치하고 있는 곳이 열이 변경되는 구간인지, 행이 변경되는 구간인지 알 필요가 있다.먼저 행과 열이 바뀌는 구간은 sq의 제곱 + sq로 구할 수 있다. (행과 열이 만나는 시점) 따라서 해당 값보다 크게 되면, 가로로 배치되는 시점이므로 행의 위치는 sq+1로 고정이며 열의 위치는 sq+1의 제곱에서 k값을 뺀 값이 k가 위치하는 열의 번호가 된다. 또는 행과 열이 만나는 시점보다 k의 값이 작게 되면, 세로로 배치되는 시점이므로 열의 위치는 sq+1로 고정이며 행의 위치는 k에서 sq의 제곱을 뺀 값이 된다. 최종 코드12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;math.h&gt; using namespace std; int main(void) { int TestCase = 0; cin &gt;&gt; TestCase; while (TestCase --) { int k; cin &gt;&gt; k; int sq = (int)sqrt(k); if(sq*sq == k) { cout &lt;&lt; sq &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt; endl; continue; } if(k &gt; sq*sq+sq) cout &lt;&lt; sq+1 &lt;&lt; &quot; &quot; &lt;&lt; sq-(k-(sq*sq)-sq)+2 &lt;&lt; endl; else cout &lt;&lt; k-(sq*sq) &lt;&lt; &quot; &quot; &lt;&lt; sq+1 &lt;&lt; endl; } return 0;} 느낀점어렵지 않았다. 간단한 공식을 알아내면 쉽게 풀 수 있는 문제였다.앞에서 뻘짓한게 아까웠다..","link":"/2021/08/25/codeforces-739-C/"},{"title":"Codeforces Round","text":"https://codeforces.com/contest/1560/problem/ACodeforces Round # (Div. ) A. TimeLimit MemoryLimit Difficulty Tags 1 S 256 MB 800 implementation Attr SubNo SolveTime Time Memory Accept? 1 126327661 +40min 1000 ms 3700KB Time limit 2 126332184 +8min (48m) 77 ms 3600KB Wrong answer 3 126336434 +8min (56m) 93 ms 3700KB Accepted 문제 요약피드백Input1-st line : Testcase (1 &lt;= t &lt;= 104)각 Testcase 마다t-th line : 1개의 정수 (1 &lt;= k &lt;= 1000) Output각 Testcase 마다1개의 정수 d : c와 마주보고있는 숫자답이 여러개일시 아무거나 출력, 답이 없으면 -1출력 문제 풀이Attr 1 (Time Limit exceeded on test 2)Attr 2 (Wrong answer on test 2)Attr 3 (Accepted!) 최종 해설 최종 코드1 느낀점","link":"/2021/08/25/codeforces-739-D/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"summary","slug":"summary","link":"/tags/summary/"},{"name":"Div.3","slug":"Div-3","link":"/tags/Div-3/"},{"name":"Problem Solve","slug":"Problem-Solve","link":"/tags/Problem-Solve/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Codeforces","slug":"Algorithm/Codeforces","link":"/categories/Algorithm/Codeforces/"},{"name":"Problems","slug":"Algorithm/Codeforces/Problems","link":"/categories/Algorithm/Codeforces/Problems/"}]}